/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name: XBMC
System Number: 1.1
Programmer: Neil Carthy (arduino@scpgwiki.com)
Comments:                                             
    
	***** License *****

	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

	***** ******* *****

	A note on the Rx/Tx Outputs
	This module is connected to XBMC.usp by outputs Rx & Tx. This module is
	responsible for all communication with the XBMC.exe via port 9090. It was
	designed this way so that one module could control the flow of requests
	and replies to prevent messages getting jammed.

	***** ******* *****

	A note on the replacement of '}' with \x7D in MAKESTRING function calls
	There is a bug in the MC3 firmware that is having issue with the curly brackets 
	in MAKESTRING. It has been confirmed with TB Support.  It can be worked around 
	by replacing trailing instances of '}' with \x7D. Reported by Josh Haskell.

*/

#SYMBOL_NAME "XBMC-Browse"
#CATEGORY "41" // Remote System Interface
#HINT "Browse/search the XBMC catalogs for video and music."  


/////////////////////Compiler Directives
#PRINT_TO_TRACE
#ENABLE_DYNAMIC
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#OUTPUT_SHIFT 7			// Shift the outputs down 7 lines on the SIMPL window

#USER_LIBRARY "Common_Functions"
/* Request IDs for different JSON-RPC commands are defined in Common_Functions.usl*/
/* Response Types for different JSON-RPC commands are defined in Common_Functions.usl*/  

/*****    DEFINE NEW CONSTANTS    *******/
//#DEFINE_CONSTANT DEBUG 1              // Uncomment this to see debug messages
#DEFINE_CONSTANT GATHER_TIMEOUT 1000    // 10 seconds
#DEFINE_CONSTANT MAX_FILENAME_LENGTH 200 
#DEFINE_CONSTANT MAX_SERIAL_STRING_LENGTH 250	// (equals 255 minus 5 characters for a delimiter) 
#DEFINE_CONSTANT BUFFER_SIZE 40000		// Socket buffer size
                                                      
/* Types of List */ 
#DEFINE_CONSTANT MOVIE_TITLE_LIST					 1
#DEFINE_CONSTANT TV_SHOW_LIST                        2 
#DEFINE_CONSTANT TV_SEASON_LIST                      3 
#DEFINE_CONSTANT TV_EPISODE_LIST                     4
#DEFINE_CONSTANT MUSIC_ARTIST_LIST                   5
#DEFINE_CONSTANT MUSIC_ALBUM_LIST                    6
#DEFINE_CONSTANT MUSIC_SONG_LIST                     7  
#DEFINE_CONSTANT MUSIC_ARTIST_CHOOSE_LIST            8	// AllSongs & Albums                                                        

#DEFINE_CONSTANT SPECIAL_SEASON						 65535

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
DIGITAL_OUTPUT  IsConnected ,
				_SKIP_,
				MovieDetails,
                TvShowDetails,
				MusicDetails,
				_SKIP_,
				SearchAvailable,
				_SKIP_,
				IsMovieList,
				IsAlbumList,
				IsTvShowList,
				IsArtistList,
				IsSongList,
				_SKIP_,
				CheckCurrentlyPlaying, // Tell XBMC.usp to update the currently-playing metadata
				ClearCurrentlyPlaying; // Tell XBMC.usp to clear the currently-playing metadata

DIGITAL_OUTPUT _SKIP_, SocketBusy; // HIGH when a JSON reply is being received;
DIGITAL_OUTPUT Loading; // HIGH when a JSON reply is being received;
ANALOG_OUTPUT ScrollBarPercentage; // Percentage (0-99) user has moved through the media list (feedback for scroll bar)
ANALOG_OUTPUT LoadingMediaPercentage; // Progress report on loading media library from 0-99

DIGITAL_OUTPUT _SKIP_, Watched[10];		// HIGH when item has already been watched.
                 	
STRING_OUTPUT 	PlotSelected$,					// The plot of the selected movie or TV showList_Summary$
				_SKIP_,
				List_Summary$,					// e.g. 7 to 12 of 15
				_SKIP_,
				Rx$,							// Json reply from XBMC (delimited by "\n")		
				_SKIP_;   

ANALOG_OUTPUT   List_CurrentScreen;		// 1 = Movies list, 2 = TV show list, 3 = TV season list etc.

STRING_OUTPUT _SKIP_,Name$[10],
				Year$[10],
				Genre$[10],
				Rating$[10],
				Runtime$[10],
				Director$[10],
				Tagline$[10],
				Thumb$[10],
				Writer$[10],
				EpisodeOrTrackNum$[10],
				SeasonOrAlbumName$[10],
				Studio$[10],
				MPAA$[10],
				SeriesOrArtistName$[10],
				Fanart$[10],
				Filename$[10];

/* Browse functionality */
DIGITAL_INPUT   _SKIP_,_SKIP_,_SKIP_,_SKIP_,_SKIP_,_SKIP_,_SKIP_,				
				List_UnWatchedOnly,	// Not implemented yet!
				List_TopPage,
				List_BottomPage,
				List_PageMinus,
				List_PagePlus,
				List_Back,
				List_Movies,
				List_Albums,
				List_TVShows, 
				List_Artists,
				List_Songs,
				List_Exit_Details_Page,
				_SKIP_;

DIGITAL_INPUT Connect; 						// When HIGH connect to the XBMC tcp socket.
DIGITAL_INPUT _SKIP_,_SKIP_;				// sent to Rx$ rather than processed internally.

ANALOG_INPUT PlayItem, SelectedItem,_SKIP_;

STRING_INPUT _SKIP_, SearchCriteria$[256], _SKIP_;	
BUFFER_INPUT Tx$[1000];						// A command to be send to the XBMC

///////////////////////////// Parameters
STRING_PARAMETER XBMC_IPAddr$[16];   //the ip of the XBMC server.
STRING_PARAMETER XBMC_HttpPort$[5];	 //the port that the XBMC server lives on
INTEGER_PARAMETER StepAmount;		 // Only return this many results from database at a time
INTEGER_PARAMETER UseJpgExtension;	 // Use '.jpg' as thumbnail extension instead of '.tbn'
STRING_PARAMETER LOGIN[30];			 // Username for http server (used to downlaod thumbnails) 
STRING_PARAMETER PASSWORD[30];		 // Password for http server (used to downlaod thumbnails)
STRING_PARAMETER XBMC_TcpPort$[5];	 //the port that the XBMC server lives on


/*******************************************************************************************
  Parameter Properties
  (Uncomment and declare parameter properties as needed)
*******************************************************************************************/
#BEGIN_PARAMETER_PROPERTIES XBMC_IPAddr$ 
    propDefaultValue = "";  
    propShortDescription = "The IP Address of the XBMC HTTP server.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES XBMC_HttpPort$
   propDefaultValue = "";   
   propShortDescription = "The port that the XBMC HTTP server is listening on. (NOT the tcp server)";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES StepAmount
	propValidUnits = unitDecimal;
    propDefaultUnit = unitDecimal;
    propDefaultValue = 10d;
    propShortDescription = "Only return this many results from database at a time.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES UseJpgExtension
	propValidUnits = unitDecimal;
    propDefaultUnit = unitDecimal;
    propDefaultValue = 0d;
    propShortDescription = "Use jpg as thumbnail extension instead of tbn";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES LOGIN
   propDefaultValue = "xbmc";   
   propShortDescription = "Login for HTTP Basic Authentication. Set 0d if no login. Max 30 chars.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES PASSWORD
   propDefaultValue = "xbmc";   
   propShortDescription = "Password for HTTP Basic Authentication. Set 0d if no password. Max 30 chars.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES XBMC_TcpPort$
   propDefaultValue = "";   
   propShortDescription = "The port that the XBMC JSON TCP server is listening on. (NOT the httpp server) (usu 9090)";
#END_PARAMETER_PROPERTIES

/*******************************************************************************************
  SOCKETS
*******************************************************************************************/
TCP_CLIENT XBMC[BUFFER_SIZE];			// Socket for connecting to XBMC on TCP port 9090
   
/*******************************************************************************************
  STRUCTURES
*******************************************************************************************/
STRUCTURE 	ListItem //Generic list item
{
	INTEGER id;
	STRING  label[MAX_SERIAL_STRING_LENGTH];
	STRING  genre[90];
	STRING 	thumbnail[MAX_FILENAME_LENGTH];
	STRING  year[10];
	INTEGER Playcount;
	INTEGER season;
	INTEGER episode;
};
STRUCTURE 	MovieListItem 
{
	INTEGER id;
	STRING  label[MAX_SERIAL_STRING_LENGTH];
	STRING  genre[90];
	STRING 	thumbnail[MAX_FILENAME_LENGTH];
	STRING  year[10];
	INTEGER Playcount;
	INTEGER Set;	// =1 means part of a Movie Set
};
STRUCTURE 	AlbumListItem
{
	INTEGER id;
	STRING  label[MAX_SERIAL_STRING_LENGTH];
	STRING  genre[50];
	STRING  artist[50];
	STRING 	thumbnail[MAX_FILENAME_LENGTH];
	STRING  year[10];
	INTEGER Playcount;
};
STRUCTURE 	SongListItem
{
	INTEGER id;
	STRING  label[MAX_SERIAL_STRING_LENGTH];
	STRING  genre[50];
	STRING  album[50];
	STRING 	thumbnail[MAX_FILENAME_LENGTH];
	STRING  duration[10];
	STRING  trackno[6];
};
STRUCTURE 	Limits
{
	INTEGER start;
	INTEGER end;
	INTEGER total;
};


   
/*******************************************************************************************
  GLOBAL VARIABLES
*******************************************************************************************/
SIGNED_INTEGER ConnectionStatus;	// Status of XBMC socket, used to determine if 
									// the Connect event needs to reconnect or do nothing.
INTEGER List_PageNumber;			// The (zero-based) current page number of the list;
INTEGER List_Total;					// The total number of items in the current browse list
INTEGER List_IDs[10];				// The ids of the items in the browse list
INTEGER OldShowListPage,OldSeasonListPage,OldArtistListPage,OldAlbumListPage;
INTEGER TvShowID, TvShowSeasonID, TvShowEpisodeID, AlbumID, ArtistID;
INTEGER PlaylistIDs[100];			// The songids/movieids etc. of the current playlist
INTEGER TCPBlocker[1];				// Semaphore for incomplete JSON packets.
INTEGER List_Position[10];			// Position of this item in the master lists

// Albums/Movies/Artists etc. are loaded all at the start
DYNAMIC AlbumListItem Albums[100];
DYNAMIC ListItem Artists[100];
DYNAMIC SongListItem Songs[50];
DYNAMIC MovieListItem Movies[100];
DYNAMIC ListItem TvShows[50];
DYNAMIC INTEGER TvShowSeasons[10];
DYNAMIC ListItem TvShowEpisodes[50];
DYNAMIC ListItem ArtistAlbums[15];
                       
NONVOLATILE INTEGER NumberOfAlbums; // The number of albums in Xbmc library. Max 65535. Will retaint value between sessions
NONVOLATILE INTEGER NumberOfArtists; // The number of artists in Xbmc library. Max 65535. Will retaint value between sessions
INTEGER NumberOfSongs;
NONVOLATILE INTEGER NumberOfMovies; // Will retain value between sessions
NONVOLATILE INTEGER NumberOfTvShows; // Max 65535. Will retain value between sessions (over loss of hardware power)
INTEGER NumberOfTvShowSeasons;
INTEGER NumberOfTvShowEpisodes;
INTEGER NumberOfArtistAlbums;
INTEGER CurrentAlbumNumber;
INTEGER CurrentArtistNumber;
INTEGER CurrentMovieNumber;
INTEGER CurrentTvShowNumber;


// Variables used in parsing response from XBMC
// They are module-level because the response might come in several parts
INTEGER ExternalRequest;			// When HIGH any data received from XBMC is to be
									// sent to Rx$ rather than processed internally.
INTEGER BatchRequest;    			// When HIGH a JSON batch request has been submitted to XBMC. 
									// Any response data received from XBMC will be ignored.

INTEGER ResponseId;					// The value of the "id" in the response. If =0 then its an announcement.
INTEGER ResponseType;				// An error, result or notification (constants defined in Common_Functions.usl)
INTEGER InResponsePropertyName;		// When =1 the loop is currently inside a property name
INTEGER ResponsePropertyNumber;		// The index of the current property
STRING  ResponsePropertyName[10][20];// An array of property names e.g. "id" or "result"
STRING  ResponsePropertyValue[10][50];// The value of the property, represented as a string.
INTEGER ResponsePropertyPosition;	// The index of the current position within the ResponseProperty string (either the name or the value)
INTEGER NumStartBrackets;			// Number of opening curly brackets '{' in JSON response
INTEGER NumEndBrackets;				// Number of closing curly brackets '}' in JSON response
INTEGER DoubleQuotesCount;			// Number of quotes (") in the response.
INTEGER prevCharacter;				// This is used to test for escaped or Unicode characters
STRING 	outputString[MAX_SERIAL_STRING_LENGTH]; // Message to be sent to Xbmc
INTEGER outputPosition;				// Current position inside outputstring$
INTEGER SendToOutput;				// When =1 send all future response characters to Tx$ OUTPUT, for XBMC.usp to process.
INTEGER InNestedObject;				// When =1 the position of the loop is inside a nested object {...{.X.}} 
INTEGER InLimitsObject;				// When =1 the position of the loop is inside a nested limits object {..."limits":{.X.}} 
INTEGER InArrayObject;				// When =1 the position of the loop is inside a nested array {...[.X.].} (square brackets)
Limits	ListLimits;
INTEGER InArrayItemName;
INTEGER InArrayNameValueNumber;
INTEGER outputArrayItemPosition;
STRING 	outputStringName[25][MAX_SERIAL_STRING_LENGTH];
STRING 	outputStringValue[25][2000];

STRING SelectedSeriesName$[MAX_SERIAL_STRING_LENGTH];
STRING SelectedGenre$[50];
STRING SelectedYear$[10];

/*******************************************************************************************
  Socket Functions
*******************************************************************************************/
/*
  	Close the connection and wait for status to show 'disconnected'
*/        
FUNCTION DisconnectFromXbmc()
{
	INTEGER count;
	count = 0;

	IF ( ConnectionStatus <> 5 )
	{
		// close the connection
	    ConnectionStatus = SocketDisconnectClient (XBMC);
	
		// wait for the connection to be established
		while( ( ConnectionStatus <> 5 ) && ( count < 10 ) )
		{
			delay( 20 );
			count = count + 1;
		}
    } 

    IsConnected = OFF;
}

/*
  	Establish a connection and wait for status to show 'connected'
*/
FUNCTION ConnectToXbmc()
{
	INTEGER count;
	count = 0;


	// Initialize module variables
	// Do this to reset module during disconnect/reconnect.
	NumStartBrackets = 0;
	NumEndBrackets = 0;
	DoubleQuotesCount = 0;
	ResponseId = 0;
	ResponseType = 0;
	InResponsePropertyName = 1;
	ResponsePropertyPosition = 1;
	SendToOutput = 0;
	InNestedObject = 0;
	ListLimits.start = 0;
	ListLimits.end = 0;
	ListLimits.total = 0;
	InArrayObject = 0;
	InArrayItemName = 1;

	NumberOfSongs = 0;
	NumberOfTvShowSeasons = 0;
	NumberOfTvShowEpisodes = 0;
	CurrentMovieNumber = 0;
	CurrentAlbumNumber = 0;
	CurrentArtistNumber = 0;
	CurrentTvShowNumber = 0;


	ScrollBarPercentage = 0;
	LoadingMediaPercentage = 0;

	// Set flag to deny access from Xbmc.usp
	SocketBusy = ON;
    
	IF ( ConnectionStatus <> 2 )
	{

		// open the connection			// '1' = always attempt to reconnect.
	    ConnectionStatus = SocketConnectClient (XBMC, XBMC_IPAddr$, AtoI(XBMC_TcpPort$), 1);
	
		// wait for the connection to be established
		while( ( ConnectionStatus <> 2 ) && ( count < 10 ) )
		{
			delay( 20 );
			count = count + 1;
		}
    } 

                  
	// Reset all flags
	SocketBusy = OFF;
	ExternalRequest = OFF;
	TCPBlocker[0] = OFF;
	Loading = OFF;
}

/*
	DELAY until socket is clear
*/
Function WaitforSocketToClear()
{
	WHILE (Loading)
	{
     	delay(1);
	}
}

SOCKETSTATUS XBMC 
{
	SIGNED_INTEGER Status;

	Status = SocketGetStatus();
    
	IF (Status = 2)
		IsConnected = ON;
	ELSE
		IsConnected = OFF;
}



/*******************************************************************************************
  XBMC Response logic
*******************************************************************************************/
/*
  	Return a string containing the xbmc parameter list for the GetMovies browse query
*/
STRING_FUNCTION MovieBrowseParameters() 
{
	STRING Params$[1024];

	// These labels from examining CFileItemHandler::FillDetails in FileItemHandler.cpp (xbmc src code)	
	// \x22 is a double-quote (")
	// Must use 'ignorearticle'=false otherwise SearchCriteria won't work
	MAKESTRING (Params$, 
		"{\x22properties\x22:[%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22videotitle\x22,\x22order\x22:\x22ascending\x22,\x22ignorearticle\x22:false%s"
								,"\x22title\x22"
								,"\x22thumbnail\x22"
								,"\x22genre\x22"
								,"\x22year\x22"
								,"\x22playcount\x22"
								,"\x22set\x22"
								,"\x7D\x7D" // MC3 bug fix
					);

	RETURN (Params$);
}

/*
  	Return a string containing the xbmc parameter list for the GetTvShow browse query
*/
STRING_FUNCTION TvShowBrowseParameters(STRING SortMethod) 
{
	STRING Params$[1024];
	MAKESTRING (Params$, 
		"{\x22properties\x22:[%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22,\x22ignorearticle\x22:false%s"
								,"\x22title\x22"
								,"\x22thumbnail\x22"
								,"\x22genre\x22"
								,"\x22year\x22"
								,"\x22playcount\x22"
								,SortMethod
								,"\x7D\x7D" // MC3 bug fix
					);

	RETURN (Params$);
}

/*
  	Return a string containing the xbmc parameter list for showing details of a movie
*/
STRING_FUNCTION MovieDetailsParameters(INTEGER movieid) 
{
	STRING Params$[1024];
     
	// These labels from examining CFileItemHandler::FillDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{\x22movieid\x22:%d,\x22properties\x22:[%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s]%s"
								,movieid
								,"\x22title\x22"
								,"\x22thumbnail\x22"
								,"\x22director\x22"
								,"\x22tagline\x22"
								,"\x22genre\x22"
								,"\x22runtime\x22"
								,"\x22year\x22"
								,"\x22rating\x22"
								,"\x22playcount\x22"
								,"\x22studio\x22"
								,"\x22plot\x22"
								,"\x22lastplayed\x22"
								,"\x22mpaa\x22"
								,"\x22file\x22"
								,"\x7D" // MC3 bug fix
					);
	RETURN (Params$);
}


/*
  	Return a string containing the xbmc parameter list for showing details of a TV Show
*/
STRING_FUNCTION TvShowDetailsParameters(INTEGER tvshowid, INTEGER seasonid, STRING SortMethod) 
{
	STRING Params$[1024];

	MAKESTRING (Params$, 
	"{\x22tvshowid\x22:%d,\x22season\x22:%d,\x22properties\x22:[%s,%s,%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22%s"
								, tvshowid, seasonid
								,"\x22title\x22"
								,"\x22thumbnail\x22"
								,"\x22showtitle\x22"
								,"\x22runtime\x22"
								,"\x22season\x22"
								,"\x22episode\x22"
								,"\x22firstaired\x22"
								,"\x22playcount\x22"
								,SortMethod
								,"\x7D\x7D" // MC3 bug fix
					);
	RETURN (Params$);
}


/*
  	Return a string containing the xbmc parameter list for showing details of a single episode of a TV Show
*/
STRING_FUNCTION EpisodeDetailsParameters(INTEGER episodeid) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{\x22episodeid\x22:%d,\x22properties\x22:[%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s]%s"
								, episodeid
								,"\x22title\x22"
								,"\x22thumbnail\x22"
								,"\x22director\x22"
								,"\x22showtitle\x22"
								,"\x22runtime\x22"
								,"\x22rating\x22"
								,"\x22writer\x22"
								,"\x22plot\x22"
								,"\x22season\x22"
								,"\x22episode\x22"
								,"\x22firstaired\x22"
								,"\x22playcount\x22"
								,"\x7D" // MC3 bug fix
					);

	#IF_DEFINED DEBUG
		PRINT("EpisodeDetailsParameters: %s" ,LEFT(Params$,200));
	#ENDIF

	RETURN (Params$);
}

/*
  	Return a string containing the xbmc parameter list for Audio Playlists
*/
STRING_FUNCTION AudioPlaylistParameters(STRING AdditionalParameters, STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	// Must use 'ignorearticle'=false otherwise SearchCriteria won't work
	MAKESTRING (Params$, 
	"{%s\x22properties\x22:[%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22,\x22ignorearticle\x22:false%s"
				,AdditionalParameters
				,"\x22artist\x22"
				,"\x22thumbnail\x22"
				,"\x22genre\x22"
				,"\x22year\x22"
				,SortMethod
				,"\x7D\x7D" // MC3 bug fix
				);


	RETURN (Params$);
}

/*
  	Return a string containing the xbmc parameter list for Artists
*/
STRING_FUNCTION ArtistsParameters(STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	// Must use 'ignorearticle'=false otherwise SearchCriteria won't work
	MAKESTRING (Params$, 
	"{\x22properties\x22:[%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22,\x22ignorearticle\x22:false%s"
				,"\x22thumbnail\x22"
				,"\x22genre\x22"
				,SortMethod
				,"\x7D\x7D" // MC3 bug fix
				);

	#IF_DEFINED DEBUG
		PRINT("ArtistsParameters: %s" ,LEFT(Params$,200));
	#ENDIF


	RETURN (Params$);
}



/*
    Take the uri given by XBMC and add http://, ip_address, port etc.
	When UseJPG = 1, Use the extension '.jpg' instead of '.tbn'. 
*/
STRING_FUNCTION ThumbnailUri(STRING uri$, INTEGER UseJPG)
{
	STRING tmpCoverPath[512];
	IF(LOGIN <> "0d" && PASSWORD <> "0d"){
		tmpCoverPath = "http://" + LOGIN + ":" + PASSWORD + "@" + XBMC_IPAddr$ + ":"+ XBMC_HttpPort$ + "/";
	}	
	ELSE{
		tmpCoverPath = "http://" + XBMC_IPAddr$ + ":"+ XBMC_HttpPort$ + "/";
	}
	IF (UseJPG)
	{
		/* 	Hack/workaround for Crestron TP's inability to display .tbn files. 
			Tested with XPanel and 8x. Mobile Pro/ProG/Android R2 work either way.
		*/
		tmpCoverPath = tmpCoverPath + "vfs/" + uri$ + "?image.jpg" ;
    }
	ELSE
		tmpCoverPath = tmpCoverPath + "vfs/" + uri$;
    RETURN (tmpCoverPath);
}

/*
    Send the plot string (usu very long) to a STRING_OUTPUT
	Done this way to overcome length restriction on Indirect Text joins
*/
FUNCTION SendPlotAsIndirectText(STRING longstring$)
{
	STRING chunk[100];	
	STRING Original$[1024];

	Original$ = longstring$;

	// Must reset the output string.
    PlotSelected$ = "";

	while (len(longstring$))
	{
		if (len(longstring$)>100)
		{
			chunk = removebylength(100, longstring$);
		}
		else
		{
			chunk = longstring$;
			longstring$ = "";
		}
		PlotSelected$ = "\xFE\x02" + chunk;
	}	

	longstring$ = Original$;
}


/*
	Set the output arrays to a default empty state
*/
FUNCTION Initialize_OutputArrays()
{
	INTEGER i;
	FOR (I = 1 TO StepAmount)
	{
     	Name$[i] = "";
		Year$[i] = "";
		Genre$[i] = "";
		Rating$[i] = "";
		Runtime$[i] = "";
		Director$[i] = "";
		Tagline$[i] = "";
		Thumb$[i] = "";
		Writer$[i] = "";
		EpisodeOrTrackNum$[i] = "";
		SeasonOrAlbumName$[i] = "";
		Studio$[i] = "";
		MPAA$[i] = "";
		SeriesOrArtistName$[i] = "";
		Fanart$[i] = "";
		Watched[i] = OFF;
		List_IDs[i] = 0;
	}

	PlotSelected$ = "";
}

/*
 	Assign the metadata stored in the STRUCTURE arrays and send to STRING outputs
*/
FUNCTION AssignListData(INTEGER Count, STRING Names$[], STRING Values$[])
{	
    INTEGER i;
	INTEGER ArraySize;
    
	CSWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) :
		{
			CurrentMovieNumber = CurrentMovieNumber+1; 
			IF (CurrentMovieNumber > NumberOfMovies)
				NumberOfMovies = CurrentMovieNumber;
                
			// REsize structure array
			ArraySize = GetNumStructureArrayCols(Movies);
			IF (CurrentMovieNumber > ArraySize)
				ResizeStructureArray(Movies, ArraySize+50);
		
			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "movieid") Movies[CurrentMovieNumber].id = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "label") Movies[CurrentMovieNumber].label = Values$[i];
				ELSE IF(Names$[i] = "genre") Movies[CurrentMovieNumber].genre = Values$[i];
				ELSE IF(Names$[i] = "year") Movies[CurrentMovieNumber].year = Values$[i];
				ELSE IF(Names$[i] = "thumbnail") Movies[CurrentMovieNumber].thumbnail = Values$[i];
				ELSE IF(Names$[i] = "playcount") Movies[CurrentMovieNumber].Playcount = AtoI(Values$[i]);				
				ELSE IF(Names$[i] = "set") 
				{
					IF (LEN(Values$[i]))
						Movies[CurrentMovieNumber].Set = 1;		
					ELSE
						Movies[CurrentMovieNumber].Set = 0;		
				}
			}
		
			IF (CurrentMovieNumber <= StepAmount)
			{
				List_Position[CurrentMovieNumber] = CurrentMovieNumber;

				List_IDs[CurrentMovieNumber] = Movies[CurrentMovieNumber].id;
				Thumb$[CurrentMovieNumber] = ThumbnailUri(Movies[CurrentMovieNumber].thumbnail,UseJpgExtension);
				Name$[CurrentMovieNumber] = Movies[CurrentMovieNumber].label;
				Year$[CurrentMovieNumber] = Movies[CurrentMovieNumber].year;
				Genre$[CurrentMovieNumber] = Movies[CurrentMovieNumber].genre;
				IF (Movies[CurrentMovieNumber].Playcount)
					Watched[CurrentMovieNumber] = ON;
				ELSE
					Watched[CurrentMovieNumber] = OFF;
			}
			LoadingMediaPercentage = MULDIV(CurrentMovieNumber, 100, NumberOfMovies); 
			List_Total = CurrentMovieNumber;
			Break;
		}
		CASE (TV_SHOW_LIST)		: 
		{ 
			CurrentTvShowNumber = CurrentTvShowNumber+1; 
			IF (CurrentTvShowNumber > NumberOfTvShows)
				NumberOfTvShows = CurrentTvShowNumber;


			// REsize structure array
			ArraySize = GetNumStructureArrayCols(TvShows);
			IF (CurrentTvShowNumber > ArraySize)
				ResizeStructureArray(TvShows, ArraySize+50);

		
			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "tvshowid") TvShows[CurrentTvShowNumber].id = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "label") TvShows[CurrentTvShowNumber].label = Values$[i];
				ELSE IF(Names$[i] = "genre") TvShows[CurrentTvShowNumber].genre = Values$[i];
				ELSE IF(Names$[i] = "thumbnail") TvShows[CurrentTvShowNumber].thumbnail = Values$[i];
				ELSE IF(Names$[i] = "year") TvShows[CurrentTvShowNumber].year = Values$[i];
				ELSE IF(Names$[i] = "playcount") TvShows[CurrentTvShowNumber].Playcount = AtoI(Values$[i]);
			}
		
			IF (CurrentTvShowNumber <= StepAmount)
			{
				List_Position[CurrentTvShowNumber] = CurrentTvShowNumber;

				List_IDs[CurrentTvShowNumber] = TvShows[CurrentTvShowNumber].id;
				Thumb$[CurrentTvShowNumber] = ThumbnailUri(TvShows[CurrentTvShowNumber].thumbnail,UseJpgExtension);
	
				SeriesOrArtistName$[CurrentTvShowNumber] = TvShows[CurrentTvShowNumber].label;

				Genre$[CurrentTvShowNumber] = TvShows[CurrentTvShowNumber].genre;
				Year$[CurrentTvShowNumber] = TvShows[CurrentTvShowNumber].year;
				IF (TvShows[CurrentTvShowNumber].Playcount)
					Watched[CurrentTvShowNumber] = ON;
				ELSE
					Watched[CurrentTvShowNumber] = OFF;
			}
            
			LoadingMediaPercentage = MULDIV(CurrentTvShowNumber, 100, NumberOfTvShows); 
			List_Total = CurrentTvShowNumber;

			Break;
		}
		CASE (TV_SEASON_LIST) 	: 
		{
			NumberOfTvShowSeasons = NumberOfTvShowSeasons+1; 

			ArraySize = GetNumArrayCols(TvShowSeasons);
			IF (NumberOfTvShowSeasons > ArraySize)
				ResizeArray(TvShowSeasons, ArraySize+10);

			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "season")
				{ 					
					if (Values$[i] = "0")
						TvShowSeasons[NumberOfTvShowSeasons] = SPECIAL_SEASON;
                    ELSE
						TvShowSeasons[NumberOfTvShowSeasons] = AtoI(Values$[i]);

                 	Break;
				}
			}
		
			IF (NumberOfTvShowSeasons <= StepAmount)
			{
				SeriesOrArtistName$[NumberOfTvShowSeasons] 	= SelectedSeriesName$;
				Genre$[NumberOfTvShowSeasons] 				= SelectedGenre$;
                Year$[NumberOfTvShowSeasons]				= SelectedYear$;

				List_Position[NumberOfTvShowSeasons] = NumberOfTvShowSeasons;
				IF(Names$[i] = "season") {
					if (Values$[i] = "0")
					{
						SeasonOrAlbumName$[NumberOfTvShowSeasons] = "Specials";
						List_IDs[NumberOfTvShowSeasons] = SPECIAL_SEASON;
					}
					ELSE
					{
						SeasonOrAlbumName$[NumberOfTvShowSeasons] = "Season " + Values$[i];
						List_IDs[NumberOfTvShowSeasons] = AtoI(Values$[i]);
					}

				}
			}

			List_Total = NumberOfTvShowSeasons;

			Break;
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
			NumberOfTvShowEpisodes = NumberOfTvShowEpisodes+1; 

			// REsize structure array
			ArraySize = GetNumStructureArrayCols(TvShowEpisodes);
			IF (NumberOfTvShowEpisodes > ArraySize)
				ResizeStructureArray(TvShowEpisodes, ArraySize+10);

		
			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "episodeid") TvShowEpisodes[NumberOfTvShowEpisodes].id = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "label") TvShowEpisodes[NumberOfTvShowEpisodes].label = Values$[i];
				ELSE IF(Names$[i] = "season") TvShowEpisodes[NumberOfTvShowEpisodes].season = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "episode") TvShowEpisodes[NumberOfTvShowEpisodes].episode = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "studio") TvShowEpisodes[NumberOfTvShowEpisodes].genre = Values$[i];
				ELSE IF(Names$[i] = "thumbnail") TvShowEpisodes[NumberOfTvShowEpisodes].thumbnail = ThumbnailUri(Values$[i],UseJpgExtension);
				ELSE IF(Names$[i] = "firstaired") TvShowEpisodes[NumberOfTvShowEpisodes].year = Values$[i];
				ELSE IF(Names$[i] = "playcount") TvShowEpisodes[NumberOfTvShowEpisodes].Playcount = AtoI(Values$[i]);
			}
		
			IF (NumberOfTvShowEpisodes <= StepAmount)
			{
				List_Position[NumberOfTvShowEpisodes] = NumberOfTvShowEpisodes;
				List_IDs[NumberOfTvShowEpisodes] = TvShowEpisodes[NumberOfTvShowEpisodes].id;
				Thumb$[NumberOfTvShowEpisodes] = TvShowEpisodes[NumberOfTvShowEpisodes].thumbnail;
				Name$[NumberOfTvShowEpisodes] = TvShowEpisodes[NumberOfTvShowEpisodes].label;
				EpisodeOrTrackNum$[NumberOfTvShowEpisodes] 	= "Episode " + ItoA(TvShowEpisodes[NumberOfTvShowEpisodes].episode);

				if (TvShowEpisodes[NumberOfTvShowEpisodes].season) 
					SeasonOrAlbumName$[NumberOfTvShowEpisodes]	= "Season " + ItoA(TvShowEpisodes[NumberOfTvShowEpisodes].season);				
				else
					SeasonOrAlbumName$[NumberOfTvShowEpisodes]	= "Special";				
				
				SeriesOrArtistName$[NumberOfTvShowEpisodes] 	= SelectedSeriesName$;
				Genre$[NumberOfTvShowEpisodes] 					= SelectedGenre$;
				Year$[NumberOfTvShowEpisodes] 					= SelectedYear$;

				IF (TvShowEpisodes[NumberOfTvShowEpisodes].Playcount)
					Watched[NumberOfTvShowEpisodes] = ON;
				ELSE
					Watched[NumberOfTvShowEpisodes] = OFF;
				MAKESTRING (List_Summary$, "1 to %d of %d", NumberOfTvShowEpisodes, NumberOfTvShowEpisodes);
			}
			ELSE
                MAKESTRING (List_Summary$, "1 to %d of %d", StepAmount, NumberOfTvShowEpisodes);

			List_Total = NumberOfTvShowEpisodes;

			Break;
		}
		CASE (MUSIC_ALBUM_LIST)  : 
		{ 
			CurrentAlbumNumber = CurrentAlbumNumber+1; 
			IF (CurrentAlbumNumber > NumberOfAlbums)
				NumberOfAlbums = CurrentAlbumNumber;

			// REsize structure array
			ArraySize = GetNumStructureArrayCols(Albums);
			IF (CurrentAlbumNumber > ArraySize)
				ResizeStructureArray(Albums, ArraySize+50);

		
			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "albumid") Albums[CurrentAlbumNumber].id = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "label") Albums[CurrentAlbumNumber].label = Values$[i];
				ELSE IF(Names$[i] = "genre") Albums[CurrentAlbumNumber].genre = LEFT(Values$[i],50);
				ELSE IF(Names$[i] = "thumbnail") Albums[CurrentAlbumNumber].thumbnail = Values$[i];
				ELSE IF(Names$[i] = "year" && AtoI(Values$[i])) Albums[CurrentAlbumNumber].year = Values$[i];
				ELSE IF(Names$[i] = "artist") Albums[CurrentAlbumNumber].artist = LEFT(Values$[i],50);

			}
		
			IF (CurrentAlbumNumber <= StepAmount)
			{
				List_Position[CurrentAlbumNumber] = CurrentAlbumNumber;
				List_IDs[CurrentAlbumNumber] = Albums[CurrentAlbumNumber].id;
		        SeasonOrAlbumName$[CurrentAlbumNumber] = Albums[CurrentAlbumNumber].label;
				Thumb$[CurrentAlbumNumber] = ThumbnailUri(Albums[CurrentAlbumNumber].thumbnail,UseJpgExtension);
				Name$[CurrentAlbumNumber] = Albums[CurrentAlbumNumber].label;
				Genre$[CurrentAlbumNumber] = Albums[CurrentAlbumNumber].genre;
				Year$[CurrentAlbumNumber] = Albums[CurrentAlbumNumber].year;
				SeriesOrArtistName$[CurrentAlbumNumber] = Albums[CurrentAlbumNumber].artist;
			}
            
			LoadingMediaPercentage = MULDIV(CurrentAlbumNumber, 100, NumberOfAlbums); 
			List_Total = NumberOfAlbums;
			Break;	
		}
		CASE (MUSIC_ARTIST_LIST)  : 
		{
			CurrentArtistNumber = CurrentArtistNumber+1;
			IF (CurrentArtistNumber > NumberOfArtists)
				NumberOfArtists = CurrentArtistNumber; 

			// REsize structure array
			ArraySize = GetNumStructureArrayCols(Artists);
			IF (CurrentArtistNumber > ArraySize)
				ResizeStructureArray(Artists, ArraySize+50);

		
			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "artistid") Artists[CurrentArtistNumber].id = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "label") Artists[CurrentArtistNumber].label = Values$[i];
				ELSE IF(Names$[i] = "genre") Artists[CurrentArtistNumber].genre = Values$[i];
				ELSE IF(Names$[i] = "thumbnail") Artists[CurrentArtistNumber].thumbnail = Values$[i];
			}
		
			IF (CurrentArtistNumber <= StepAmount)
			{
				List_Position[CurrentArtistNumber] = CurrentArtistNumber;
				List_IDs[CurrentArtistNumber] = Artists[CurrentArtistNumber].id;
				Thumb$[CurrentArtistNumber] = ThumbnailUri(Artists[CurrentArtistNumber].thumbnail,UseJpgExtension);
				Name$[CurrentArtistNumber] = Artists[CurrentArtistNumber].label;
			}
			
			LoadingMediaPercentage = MULDIV(CurrentArtistNumber, 100, NumberOfArtists);
			List_Total = CurrentArtistNumber;
			Break;
		}
		CASE (MUSIC_ARTIST_CHOOSE_LIST)  : 
		{ 
			NumberOfArtistAlbums = NumberOfArtistAlbums+1; 

			// REsize structure array
			ArraySize = GetNumStructureArrayCols(ArtistAlbums);
			IF (NumberOfArtistAlbums > ArraySize)
				ResizeStructureArray(ArtistAlbums, ArraySize+5);

			IF(NumberOfArtistAlbums=1)
			{
				ArtistAlbums[NumberOfArtistAlbums].id = 0;
				ArtistAlbums[NumberOfArtistAlbums].label = "All Songs";
               	List_IDs[NumberOfArtistAlbums] = 0;
				Name$[NumberOfArtistAlbums] = "All Songs";
			    SeasonOrAlbumName$[NumberOfArtistAlbums] = "All Songs";
				NumberOfArtistAlbums=2;
			}
		

			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "albumid") ArtistAlbums[NumberOfArtistAlbums].id = AtoI(Values$[i]);
				ELSE IF(Names$[i] = "label") ArtistAlbums[NumberOfArtistAlbums].label = Values$[i];
				ELSE IF(Names$[i] = "genre") ArtistAlbums[NumberOfArtistAlbums].genre = Values$[i];
				ELSE IF(Names$[i] = "thumbnail") 
				{
					ArtistAlbums[NumberOfArtistAlbums].thumbnail = ThumbnailUri(Values$[i],UseJpgExtension);
				}
				ELSE IF(Names$[i] = "year" && AtoI(Values$[i])) ArtistAlbums[NumberOfArtistAlbums].year = Values$[i];

			}
		
			IF (NumberOfArtistAlbums <= StepAmount)
			{
				List_Position[NumberOfArtistAlbums] = NumberOfArtistAlbums;
				List_IDs[NumberOfArtistAlbums] = ArtistAlbums[NumberOfArtistAlbums].id;
		        SeasonOrAlbumName$[NumberOfArtistAlbums] = ArtistAlbums[NumberOfArtistAlbums].label;
				Thumb$[NumberOfArtistAlbums] = ArtistAlbums[NumberOfArtistAlbums].thumbnail;
				Name$[NumberOfArtistAlbums] = ArtistAlbums[NumberOfArtistAlbums].label;
				Genre$[NumberOfArtistAlbums] = ArtistAlbums[NumberOfArtistAlbums].genre;
				Year$[NumberOfArtistAlbums] = ArtistAlbums[NumberOfArtistAlbums].year;

				MAKESTRING (List_Summary$, "1 to %d of %d", NumberOfArtistAlbums, NumberOfArtistAlbums);
			}
			ELSE
			{
				IF (NumberOfArtistAlbums % StepAmount = 0 )
					MAKESTRING (List_Summary$, "1 to %d of %d", StepAmount, NumberOfArtistAlbums);
            }
			List_Total = NumberOfArtistAlbums;
			Break;	
		}

		CASE (MUSIC_SONG_LIST)  : 
		{
			NumberOfSongs = NumberOfSongs+1; 

			// REsize structure array
			ArraySize = GetNumStructureArrayCols(Songs);
			IF (NumberOfSongs > ArraySize)
				ResizeStructureArray(Songs, ArraySize+50);

		
			FOR (i = 1 TO Count)
			{		
		    	IF (Names$[i] = "songid") 
				{
					Songs[NumberOfSongs].id = AtoI(Values$[i]);
                    IF (AlbumID)
						PlaylistIDs[NumberOfSongs] = Songs[NumberOfSongs].id;
				}
				ELSE IF(Names$[i] = "label") Songs[NumberOfSongs].label = Values$[i];
				ELSE IF(Names$[i] = "album") Songs[NumberOfSongs].album = LEFT(Values$[i],50);
				ELSE IF(Names$[i] = "genre") Songs[NumberOfSongs].genre = LEFT(Values$[i],50);
				ELSE IF(Names$[i] = "track") Songs[NumberOfSongs].trackno = ItoA((AtoL(Values$[i]) % 65536));
				ELSE IF(Names$[i] = "duration") Songs[NumberOfSongs].duration = ConvertToTime(AtoI(Values$[i]));
				ELSE IF(Names$[i] = "thumbnail") 
				{
					Songs[NumberOfSongs].thumbnail = ThumbnailUri(Values$[i],UseJpgExtension);
				}
			}
		
			IF (NumberOfSongs <= StepAmount)
			{
				List_Position[NumberOfSongs] = NumberOfSongs;
				List_IDs[NumberOfSongs] = Songs[NumberOfSongs].id;
				Thumb$[NumberOfSongs] = Songs[NumberOfSongs].thumbnail;
				Name$[NumberOfSongs] = Songs[NumberOfSongs].label;
				Genre$[NumberOfSongs] = Songs[NumberOfSongs].genre;
		        SeasonOrAlbumName$[NumberOfSongs] = Songs[NumberOfSongs].album;
		        EpisodeOrTrackNum$[NumberOfSongs] = Songs[NumberOfSongs].trackno;
		        Runtime$[NumberOfSongs] = Songs[NumberOfSongs].duration;
				MAKESTRING (List_Summary$, "1 to %d of %d", NumberOfSongs, NumberOfSongs);
			}
			ELSE
				MAKESTRING (List_Summary$, "1 to %d of %d", StepAmount, NumberOfSongs);

			List_Total = NumberOfSongs;
			Break;		
		}
        DEFAULT: Print("XBMC-Browse.usp: (FUNCTION AssignListData): Invalid ListID (%d)", List_CurrentScreen);
	}
}

/*
    Assign the returned name/value pairs to Outputs

	Called from ProcessResponse()
*/
FUNCTION AssignDetailsData(INTEGER Count, STRING Names$[], STRING Values$[])
{	
    INTEGER i;

	FOR (i = 1 TO Count)
	{		
     	IF (Names$[i] = "file") Filename$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "title") Name$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "artist") SeriesOrArtistName$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "genre") Genre$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "director") Director$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "year") Year$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "runtime") Runtime$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "duration") Runtime$[SelectedItem] = ConvertToTime(AtoI(Values$[i]));
		ELSE IF(Names$[i] = "rating") Rating$[SelectedItem] = Round(Values$[i],2);		
        ELSE IF(Names$[i] = "studio") Studio$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "writingcredits") Writer$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "tagline") TagLine$[SelectedItem] = Values$[i];
		ELSE IF(Names$[i] = "mpaa") MPAA$[SelectedItem] = Values$[i];
        ELSE IF(Names$[i] = "episode") EpisodeOrTrackNum$[SelectedItem] = "Episode "+Values$[i];
		ELSE IF(Names$[i] = "firstaired") Year$[SelectedItem] = "First aired on: "+Values$[i];
		ELSE IF(Names$[i] = "season") SeasonOrAlbumName$[SelectedItem] = "Season " + Values$[i];	
		ELSE if(Names$[i] = "thumbnail") Thumb$[SelectedItem] = ThumbnailUri(Values$[i],UseJpgExtension);
		ELSE IF(Names$[i] = "plot")
		{
			SendPlotAsIndirectText(Values$[i]);
		}
	}
}
      
/*
	Process the returned limits JSON object

	Called from ProcessResponse()
*/
FUNCTION ProcessLimitsObject()
{
	INTEGER i;

	FOR(i = 0 to ResponsePropertyNumber)
	{
		#IF_DEFINED 
			DEBUG PRINT("ProcessLimitsObject(): ResponsePropertyName(%s), ResponsePropertyValue(%s)"
				,ResponsePropertyName[i], ResponsePropertyValue[i]); 
		#ENDIF

    	IF(ResponsePropertyName[i] = "start")
		{
        	ListLimits.start = AtoI(ResponsePropertyValue[i]);
		}
	    ELSE IF(ResponsePropertyName[i] = "end")
		{
        	ListLimits.end = AtoI(ResponsePropertyValue[i]);
		}
	    ELSE IF(ResponsePropertyName[i] = "total")
		{
        	ListLimits.total = AtoI(ResponsePropertyValue[i]);
		}
	}
    
	
	IF (ListLimits.total)      
	{	
		CSWITCH (List_CurrentScreen)
		{
			CASE (MOVIE_TITLE_LIST) :
			{			
				IF (ListLimits.total != NumberOfMovies)
					NumberOfMovies = ListLimits.total;  
				MAKESTRING (List_Summary$, "1 to %d of %d", StepAmount, NumberOfMovies);
				Break;
			}
			CASE (TV_SHOW_LIST)		: 
			{ 
				IF (ListLimits.total != NumberOfTvShows)
					NumberOfTvShows = ListLimits.total;        
				MAKESTRING (List_Summary$, "1 to %d of %d", StepAmount, NumberOfTvShows);
				Break;
			}
			CASE (TV_SEASON_LIST) 	: 
			{
				Break;
			}
			CASE (TV_EPISODE_LIST)  : 
			{ 
				Break;
			}
			CASE (MUSIC_ALBUM_LIST)  : 
			{ 
				IF (ListLimits.total != NumberOfAlbums)
					NumberOfAlbums = ListLimits.total;
   				MAKESTRING (List_Summary$, "1 to %d of %d", StepAmount, NumberOfAlbums);
				Break;	
			}
			CASE (MUSIC_ARTIST_LIST)  : 
			{
				IF (ListLimits.total != NumberOfArtists)
					NumberOfArtists = ListLimits.total;
                MAKESTRING (List_Summary$, "1 to %d of %d", StepAmount, NumberOfArtists);
				Break;
			}
			CASE (MUSIC_ARTIST_CHOOSE_LIST)  : 
			{ 
				Break;	
			}
			CASE (MUSIC_SONG_LIST)  : 
			{
				Break;		
			}
	        DEFAULT: Print("XBMC-Browse.usp: (FUNCTION ProcessLimitsObject): Invalid ListID (%d)", List_CurrentScreen);
		}		
	}
 	
}

/*
    This function is called from ProcessResponse when there is enough information
	in the module-level variables to determine response type and response id.
                                                                
	Response id is the id of the original request that was submitted to xbmc
	Response type is one of 'result', 'error' or 'Notification'.
	
*/
FUNCTION DetermineIdAndResponseType()
{
	INTEGER i;
     
	//Initialize
	ResponseId = 0;
	ResponseType = 0;

	#IF_DEFINED DEBUG PRINT("%s","Entering DetermineIdAndResponseType"); #ENDIF

	// Determine response id
	FOR(i = 0 to ResponsePropertyNumber)
	{
    	IF(ResponsePropertyName[i] = "id")
		{
			ResponseId = AtoI(ResponsePropertyValue[i]);
			#IF_DEFINED DEBUG PRINT("Response id:%d",ResponseId); #ENDIF
			Break;
		}
	}

	// Determine response type
	FOR(i = 0 to ResponsePropertyNumber)
	{
    	IF(ResponsePropertyName[i] = "result")
		{
			ResponseType = JSON_RESULT;
			#IF_DEFINED DEBUG PRINT("Response Type:%s","result"); #ENDIF
			Break;
		}
		ELSE IF (ResponsePropertyName[i] = "error")
		{
			ResponseType = JSON_ERROR;
			#IF_DEFINED DEBUG PRINT("Response Type:%s","error"); #ENDIF
			Break;
		}
	} 	
	IF (ResponseType = 0)
	{
		ResponseType = JSON_NOTIFY;		
		#IF_DEFINED DEBUG PRINT("Response Type:%s","Notification"); #ENDIF
	}
}

/*
	Prepare the start of the OutputString for sending on Tx$ to XBMC.usp.
	The pipe character (|) acts as a delimiter.
*/
FUNCTION PrepareOutputString()
{
	INTEGER i;
	
	IF (ResponseType=JSON_NOTIFY)
	{
		FOR (i = 0 TO ResponsePropertyNumber)
		{
			IF (ResponsePropertyName[i] = "method")
			{
				MAKESTRING(outputString, "%d|%s|data:", ResponseType, ResponsePropertyValue[i]);
				outputPosition = (LEN(outputString)+1) MOD MAX_SERIAL_STRING_LENGTH;
			    if (outputPosition = 0) outputPosition = 1;
				Break;
			}
		}    
	}
	ELSE
	{
        MAKESTRING(outputString, "%d|%d|", ResponseType, ResponseId);
		outputPosition = (LEN(outputString)+1) MOD MAX_SERIAL_STRING_LENGTH;
	    if (outputPosition = 0) outputPosition = 1;
	}

}

/*
    REset the variables that hold name/value pairs during processing
*/
FUNCTION ResetNameValueVariables()
{
	ResponsePropertyNumber = 0;
	ResponsePropertyPosition = 1;
	SetArray(ResponsePropertyName, "");
	SetArray(ResponsePropertyValue, "");
	InResponsePropertyName = 1;
}
/*
	Process a string received from the XBMC socket buffer.
	The string is expected to be in JSON-RPC format.

	If we are handling a response for XBMC.usp (ExternalRequest=ON) then any content received is 
	forwarded directly to the Tx output, minus some unnecessary whitespace characters.

  	When sending content to serial out (RX$) the content is delimited by '\n'. The correct location 
	for the delimiter is determined by  counting curly brackets ({..}). The counting is only done 
	if the curly brackets are found outside strings (i.e. When the number of double quotes is even)

*/ 
FUNCTION ProcessResponse(STRING fromBuffer)
{
	INTEGER i;
	INTEGER loop;
	INTEGER character;
	INTEGER inputLength;
	INTEGER SkipCharacter;
	INTEGER ExtendedAscii;
	
	//Semaphore to ensure only 1 thread at a time
	//Using module-level variables so this is required.
	//I'm aware it could block forever.
	WHILE (TCPBlocker[0]) 
	{	
		Delay(5);
	}	
	TCPBlocker[0] = ON;

	inputLength = len(fromBuffer);


	#IF_DEFINED DEBUG 
		PRINT("Entering ProcessResponse(), buffer: (%d) %s", inputLength, LEFT(fromBuffer, 100)); 
	#ENDIF
	
	for(loop = 1 to inputLength) //step through every character of Buffer input
	{
		SkipCharacter = 0; //reset for each character
		character = byte(fromBuffer, loop); //extract it
		switch(character) //examine it
		{
			case ('{'): // this marks either i) the start of the response or ii) the start of a nested object
			{
				IF (IsEven(DoubleQuotesCount)) // only valid if outside a string
					{
            			NumStartBrackets = NumStartBrackets + 1;

						IF (NumStartBrackets = 1) //start of a nested object
						{
                            SkipCharacter = 1;
						}
						ELSE
						{
                            
							IF (ResponseType = 0)
								DetermineIdAndResponseType();
                            
							IF ( !InNestedObject && 
									(ExternalRequest || ResponseType = JSON_NOTIFY || 
										(ResponseID>0 && ResponseId <= REQUESTID_VIDEOPLAYLIST_GETITEMS) )
								)
							{
                                PrepareOutputString();
								SendToOutput = 1;
								InNestedObject = 1;
							}

							IF (SendToOutput = 0)	
							{
								SkipCharacter = 1;

								IF ((NumStartBrackets - NumEndBrackets) = 2)
								{
                                    ResetNameValueVariables();
								}
								ELSE IF ((NumStartBrackets - NumEndBrackets) = 3)
								{	
									IF (ResponsePropertyName[ResponsePropertyNumber] = "limits")
									{
	                                 	InLimitsObject = 1;
	                                    ResetNameValueVariables();									
									}
									ELSE
									{
                                    	InNestedObject = 1;
										outputArrayItemPosition = 1;
										ResetNameValueVariables();
									}
	
								}
				
							/*#IF_DEFINED 
								DEBUG PRINT("Limits: %c, SendToOutput(%d), StartBrackets(%d), EndBrackets(%d), InLimitsObject(%d), InNestedObject(%d)"
									, character, SendToOutput, NumStartBrackets, NumEndBrackets, InLimitsObject, InNestedObject); 
							#ENDIF


							#IF_DEFINED 
								DEBUG PRINT("Limits: %c, ResponsePropertyNumber(%d), ResponsePropertyName[ResponsePropertyNumber](%s)"
									, character, ResponsePropertyNumber, ResponsePropertyName[ResponsePropertyNumber]); 
							#ENDIF*/

    						}            	
                             
						}

					}
			}
			case ('}'): // this marks either i) the end of the response or ii) the end of a nested object
			{
				IF (IsEven(DoubleQuotesCount))
				{
           			NumEndBrackets = NumEndBrackets + 1;

					IF (SendToOutput && InNestedObject && ((NumStartBrackets - NumEndBrackets) = 1))
						InNestedObject = 0;	

					IF (NumStartBrackets > 0 && NumEndBrackets > 0 
						&& NumStartBrackets = NumEndBrackets)
						SkipCharacter = 1;

					IF (InLimitsObject) //now at end of this object... process
					{
                        ProcessLimitsObject();
						
                        SkipCharacter = 1;
			            ResetNameValueVariables();
						InLimitsObject = 0;

					}
					ELSE IF (!SendToOutput) 
					{
                        SkipCharacter = 1;
					}
				}
			}
            case (DBLQUOTE): // " (double quotes)
			{
				IF (prevCharacter != BACKSLASH) // Avoid case where double quote is escaped (\")
				{
            		DoubleQuotesCount = DoubleQuotesCount + 1;
					IF (!SendToOutput || !InNestedObject)
						SkipCharacter = 1;
				}
			}
			case (TAB): SkipCharacter = 1;  //
			case (LF):  SkipCharacter = 1;  // Ignore whitespace/non-printing characters 
			case (CR):  SkipCharacter = 1;  //
			case (SPACE):  					//
			{
				IF (IsEven(DoubleQuotesCount))
				{
            		SkipCharacter = 1; // ignore spaces outside strings
				}
			}
			case (','):
			{
				// Ignore the comma that seperates properties
				IF (IsEven(DoubleQuotesCount) && SendToOutput = 0)
				{
           			SkipCharacter = 1;
					InResponsePropertyName = 1;
					ResponsePropertyPosition = 1;
					ResponsePropertyNumber = ResponsePropertyNumber + 1;
					IF (InArrayObject || InNestedObject)
					{
						InArrayItemName = 1;			
                     	outputArrayItemPosition = 1;
						InArrayNameValueNumber = InArrayNameValueNumber + 1;
					}			
                }
			}
            case (':'):
			{
				// Ignore the colon that seperates property names from values
				IF (IsEven(DoubleQuotesCount) && SendToOutput =0)
				{
					SkipCharacter = 1;
					InResponsePropertyName = 0;
					ResponsePropertyPosition = 1;
					IF (InArrayObject || InNestedObject)
					{
						InArrayItemName = 0;			
                     	outputArrayItemPosition = 1;
					}
				}
			}
            case ('['):
			{
				IF (BatchRequest) 
					SkipCharacter = 1;
				ELSE IF (IsEven(DoubleQuotesCount) && SendToOutput =0)
				{
					SkipCharacter = 1;
					InArrayObject = 1;
					outputArrayItemPosition = 1;

					IF (ResponseType != 0)
						ResetNameValueVariables();			
				}
			}
            case (']'):
			{
				IF (BatchRequest) 
				{
					SkipCharacter = 1;
                    BatchRequest = OFF;
				}
				ELSE IF (IsEven(DoubleQuotesCount) && SendToOutput =0)
				{
					SkipCharacter = 1;
					InArrayObject = 0;
				}
			}


			case (BACKSLASH):
			{
            	IF (IsOdd(DoubleQuotesCount)) // Inside a string
				{
					IF (prevCharacter != BACKSLASH)	// Avoid case where backslash is escaped (\\)		
						SkipCharacter = 1;
				}

			}
		}
        
        // Handle 2-byte UTF-8 characters
		// ConvertUtf8ToAscii() is in CommonFunctions.usl
		if (character > 126) // not ASCII
		{						
			if (prevCharacter < 127)
				SkipCharacter = 1;
			ELSE
			{
                ExtendedAscii = 92;
				ExtendedAscii = ConvertUtf8ToAscii(prevCharacter, character); // This function is very simplistic
				character = ExtendedAscii;
			}
		}
    
		/*#IF_DEFINED DEBUG
			IF (InNestedObject)
			{
			IF (!InArrayObject && !InNestedObject)
				PRINT("ProcessResponse: %c, loop(%d), InPropName(%d), SkipC(%d), StartB(%d), EndB(%d), Num(%d), Name(%s), Value(%s)"
					, character, loop, InResponsePropertyName, SkipCharacter, NumStartBrackets, NumEndBrackets, ResponsePropertyNumber
					, ResponsePropertyName[ResponsePropertyNumber], ResponsePropertyValue[ResponsePropertyNumber]); 
			ELSE 
				PRINT("%c, loop(%d), InArrayObject(%d), InArrayItemName(%d), ItemPosition(%d), Number(%d), name(%s), value(%s)"
					, character, loop, InArrayObject, InArrayItemName, outputArrayItemPosition
					, InArrayNameValueNumber, outputStringName[InArrayNameValueNumber], outputStringValue[InArrayNameValueNumber]); 
			}
			ELSE
				PRINT("%c - %d", character, SkipCharacter);
		#ENDIF*/

		//append the character
		IF (!SkipCharacter)
		{
			IF (SendToOutput)
			{
        		setString(chr(character), outputPosition, outputString);//append the character
				outputPosition = ((outputPosition + 1) MOD MAX_SERIAL_STRING_LENGTH);
                if (outputPosition = 0) outputPosition = 1;
			}
			ELSE
			{
				IF (InArrayObject || InNestedObject)
				{
					IF (InArrayItemName = 1)
					{
						//append the character
						setString(chr(character), outputArrayItemPosition, outputStringName[InArrayNameValueNumber]);
						outputArrayItemPosition = outputArrayItemPosition + 1;					
					}
					ELSE
					{
						//append the character
						setString(chr(character), outputArrayItemPosition, outputStringValue[InArrayNameValueNumber]);
						outputArrayItemPosition = outputArrayItemPosition + 1;
					}
				}
				ELSE
				{
					IF (InResponsePropertyName)
						setString(chr(character), ResponsePropertyPosition, ResponsePropertyName[ResponsePropertyNumber]);
					ELSE
						setString(chr(character), ResponsePropertyPosition, ResponsePropertyValue[ResponsePropertyNumber]);
	
					/*#IF_DEFINED DEBUG
						IF (NumStartBrackets >= 3)
							PRINT("%c, PropertyNumber(%d), InName(%d), PropertyName(%s), PropertyValue(%s)"
							, character, ResponsePropertyNumber, InResponsePropertyName
							, ResponsePropertyName[ResponsePropertyNumber]
							, ResponsePropertyValue[ResponsePropertyNumber]); 
					#ENDIF*/
		
					ResponsePropertyPosition = ResponsePropertyPosition + 1;
				}
            }
        }

		// Send the temp string to the Rx Output if the counter has looped, or hit end of input data
        IF (SendToOutput && LEN(outputString) && (outputPosition = 1 || loop = inputLength))
		{
			Rx$ = outputString; //Send to XBMC.usp

            outputPosition = 1;
			outputString = "";
		}

		IF (!SendToOutput && (InArrayObject || InNestedObject))
		{
			// Test for end of Array item
			IF (IsEven(DoubleQuotesCount) && character = '}')
			{
				IF ( MovieDetails = ON || TvShowDetails = ON)
					CALL AssignDetailsData(InArrayNameValueNumber, outputStringName, outputStringValue);	
				ELSE
					CALL AssignListData(InArrayNameValueNumber, outputStringName, outputStringValue);             

				SetArray(outputStringName, "");
				SetArray(outputStringValue, "");
				InArrayNameValueNumber = 1;
				outputArrayItemPosition = 1;
				InArrayItemName = 1;
				InNestedObject = 0;
			}
		}	
		ELSE
		{

			// Test for the end of the entire message (using count of curly brackets)
			IF (NumEndBrackets > 0 && NumStartBrackets = NumEndBrackets)
			{
           
				IF (ResponseType = 0)
	                DetermineIdAndResponseType();
				
	        	IF (ExternalRequest && !SendToOutput)
				{
	                PrepareOutputString();
					SendToOutput = 1;
					MakeString(outputString,"%sresult:%s", outputString, ResponsePropertyValue[ResponsePropertyNumber]);            	
					Rx$ = outputString;
				}
			
				IF (SendToOutput)
		            IF (outputPosition != 1 && loop != inputLength)
	   	    	    	Rx$ = outputString + "\n";
					ELSE
						Rx$ = "\n";
	
			    NumStartBrackets = 0;
				NumEndBrackets = 0;
				DoubleQuotesCount = 0;			
				outputPosition = 1;
				outputString = "";
				SendToOutput = 0;
				InNestedObject = 0;
                InArrayItemName = 1;
				InArrayObject = 0;
				InArrayNameValueNumber = 1;
				InLimitsObject = 0;
	
				ResponsePropertyNumber = 0;
				ResponsePropertyPosition = 1;
				SetArray(ResponsePropertyName, "");
				SetArray(ResponsePropertyValue, "");
				InResponsePropertyName = 1;
	
				ResponseId = 0;
				ResponseType = 0;
		
				SocketBusy = OFF;
				
				// External requests do not set the loading flag... 
				//therefore they shouldn't unset it
				IF (!ExternalRequest) Loading = OFF;  
				
				ExternalRequest = OFF;
			}
        }
		
		prevCharacter = character;
	}

	TCPBlocker[0] = OFF;
  
}

/*
	Send a string to the XBMC Socket

	No authentication
*/
Function SendToSocket(STRING Command$)
{
    
	// don't send anything if the socket isn't open
	IF (IsConnected = OFF)
		RETURN;

	// don't send anything if a long running query is already in progress
	IF (Loading = ON)
		RETURN;
                   
	// If the Socket is busy then set a flag to get control of it
	WHILE (SocketBusy)
	{
    	Loading = ON;
		Delay(1);
	}

	// Send out the command in chunks
	WHILE (LEN(Command$))
	{
		Loading = ON;
		SocketBusy = ON;

		IF (LEN(Command$)>250)
		{
			// Send to soucket in chunks
			SocketSend(XBMC, REMOVEBYLENGTH(250, Command$));
		}
		ELSE
		{
			// send last chunk
			SocketSend(XBMC, Command$);
			Command$ = "";
		}
	}
	                        
}

/*
	Send the JSON-RPC command via the TCP socket

	No authentication
*/
Function SendJsonCommand(INTEGER id,  STRING Method , STRING Arguments)
{
	STRING Command$[16384];
    
    IF (LEN(Arguments) = 0)
	{
		// \x22 is a double quote (")
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22}"
			,id ,Method);
	}
	ELSE
	{
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22,\x22params\x22:%s}"
			,id ,Method, Arguments);
	}

	#IF_DEFINED DEBUG
		PRINT("Xbmc-Browse: SendJsonCommand: %s" ,LEFT(Command$,200));
	#ENDIF
                   
	SendToSocket(Command$);                     
}

/*
	Make the JSON command call that retrieves the details of a movie, in
	particular the plot (which is usually a long string)

	This method is called from 'SelectedItem'.	
*/
FUNCTION GetMovieDetails(INTEGER movieid)
{
	CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETMOVIEDETAILS, 
				"VideoLibrary.GetMovieDetails", MovieDetailsParameters(movieid));

}

/*
	Make the JSON command call that retrieves the details of a tv episode (in
	particular the plot).

	This method is called from 'SelectedItem'.		
*/
FUNCTION GetEpisodeDetails(INTEGER episodeid)
{
	CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETEPISODEDETS, 
				"VideoLibrary.GetEpisodeDetails", EpisodeDetailsParameters(episodeid));

}


/*
	Update the STRING_OUTPUT arrays that send Browse info to the Xpanel/iPad/TouchPanel

	Depends on the global variable 'List_CurrentScreen'

	The list is paginated by 'StepAmount' 

	The parameter 'start' is the number first item on the current page
	If start=0 then use current page number (List_PageNumber)
*/
FUNCTION RepopulateOutputList(INTEGER start)
{
	INTEGER end;
	INTEGER i,j;
        
	IF (start)
    {
		// Check if on first page
		IF (start < StepAmount)
			start = 1;

		List_PageNumber = ((start-1) - ((start-1) MOD StepAmount)) / StepAmount;
		end = (start-1) + StepAmount;		
	}
	ELSE
	{
		start = List_PageNumber*StepAmount + 1;
		end = (List_PageNumber+1)*(StepAmount);
	}

	IF (end > List_Total) end = List_Total;
	
	MAKESTRING(List_Summary$, "%d to %d of %d", start, end, List_Total);
	ScrollBarPercentage = MULDIV(start, 100, List_Total);
	#IF_DEFINED DEBUG
		PRINT("ScrollBarPercentage: %d (position:%d, list_total:%d)", ScrollBarPercentage, start, List_Total);
	#ENDIF


	CALL Initialize_OutputArrays();   

	CSWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) :
		{
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{                               
					List_IDs[i] = Movies[j].id;
					Thumb$[i] = ThumbnailUri(Movies[j].thumbnail,UseJpgExtension);
					Name$[i] = Movies[j].label;
					Genre$[i] = Movies[j].genre;
					Year$[i] = Movies[j].year;
 
					List_Position[i] = j;

					IF (Movies[j].Playcount)
						Watched[i] = ON;
					ELSE
						Watched[i] = OFF;
				}
			}
			Break;
		}
		CASE (TV_SHOW_LIST)		: 
		{ 
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{                               
					List_IDs[i] = TvShows[j].id;
					Thumb$[i] = ThumbnailUri(TvShows[j].thumbnail,UseJpgExtension);
					
 					SeriesOrArtistName$[i] = TvShows[j].label;

					Genre$[i] = TvShows[j].genre;
					Year$[i] = TvShows[j].year;

					List_Position[i] = j;

					IF (TvShows[j].Playcount)
						Watched[i] = ON;
					ELSE
						Watched[i] = OFF;
				}
			}
			Break;
		}
		CASE (TV_SEASON_LIST) 	: 
		{
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{      
					List_IDs[i] = TvShowSeasons[j];
                    
					SeriesOrArtistName$[i] = SelectedSeriesName$;
					Genre$[i]				= SelectedGenre$;
					Year$[i]				= SelectedYear$;
					List_Position[i] = j;

					if (TvShowSeasons[j] = SPECIAL_SEASON)
						SeasonOrAlbumName$[i] = "Specials";        
					ELSE					
						SeasonOrAlbumName$[i] = "Season " + ItoA(TvShowSeasons[j]);        

				}
			}

			Break;
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{                               
					List_IDs[i] = TvShowEpisodes[j].id;
					Thumb$[i] = TvShowEpisodes[j].thumbnail;
					Name$[i] = TvShowEpisodes[j].label;

					List_Position[i] = j;
					Genre$[i]				= SelectedGenre$;
					Year$[i]				= SelectedYear$;
					EpisodeOrTrackNum$[i] 	= "Episode " + ItoA(TvShowEpisodes[j].episode);
					
					if (TvShowEpisodes[j].season)
						SeasonOrAlbumName$[i]	= "Season " + ItoA(TvShowEpisodes[j].season);
                    ELSE
						SeasonOrAlbumName$[i]	= "Special";

					IF (TvShowEpisodes[j].Playcount)
						Watched[i] = ON;
					ELSE
						Watched[i] = OFF;
				}
			}
			Break;
		}
		CASE (MUSIC_ALBUM_LIST)  : 
		{ 
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{                               
					List_IDs[i] = Albums[j].id;
					Thumb$[i] = ThumbnailUri(Albums[j].thumbnail,UseJpgExtension);
					Name$[i] = Albums[j].label;
					Genre$[i] = Albums[j].genre;
					SeriesOrArtistName$[i] = Albums[j].artist;
					Year$[i] = Albums[j].year;
					List_Position[i] = j;
				}
			}
			Break;
		}
		CASE (MUSIC_ARTIST_LIST)  : 
		{ 
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{                               
					List_IDs[i] = Artists[j].id;
					Thumb$[i] = ThumbnailUri(Artists[j].thumbnail,UseJpgExtension);
					Name$[i] = Artists[j].label;
					List_Position[i] = j;
				}
			}
			Break;
		}
		CASE (MUSIC_ARTIST_CHOOSE_LIST)  : 
		{ 
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{                               
					List_IDs[i] = ArtistAlbums[j].id;
					Thumb$[i] = ArtistAlbums[j].thumbnail;
					Name$[i] = ArtistAlbums[j].label;
					Genre$[i] = ArtistAlbums[j].genre;
					Year$[i] = ArtistAlbums[j].year;
					List_Position[i] = j;
				}
			}
			Break;
		}

		CASE (MUSIC_SONG_LIST)  : 
		{ 
        	FOR (i = 1 to StepAmount)
			{
				j = start+i-1;
				IF (j <= end)
				{                               
					List_IDs[i] = Songs[j].id;
					Thumb$[i] = Songs[j].thumbnail;
					Name$[i] = Songs[j].label;
					Genre$[i] = Songs[i].genre;
		      		SeasonOrAlbumName$[i] = Songs[i].album;
		      		EpisodeOrTrackNum$[i] = Songs[i].trackno;
		        	Runtime$[i] = Songs[i].duration;
					List_Position[i] = j;
				}
			}
			Break;
		}
        DEFAULT: Print("XBMC.usp: (FUNCTION RepopulateOutputList): Invalid ListID (%d)", List_CurrentScreen);
	}
}

/*
	Make the JSON command call that retrieves a browse list e.g. of Movies or Albums

	The reply from xbmc will be handled first by ProcessResponse and then AssignListData 

	The constants (e.g. REQUESTID_MOVIELIBRARY_GETMOVIES) are defined in Common_Functions.usl
*/
FUNCTION RepopulateMediaList()
{
	STRING method[25];
	STRING Params$[512];

	CALL Initialize_OutputArrays();
	SetArray(PlaylistIDs,0);
     
	CSWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) :
		{
			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETMOVIES, 
				"VideoLibrary.GetMovies", MovieBrowseParameters());
            BREAK;
		}
		CASE (TV_SHOW_LIST)		: 
		{ 
			method = "VideoLibrary.GetTvShows"; 
			Params$ = TvShowBrowseParameters("sorttitle");

			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETTVSHOWS, method, Params$);
			BREAK;
		}
		CASE (TV_SEASON_LIST) 	: 
		{
			method = "VideoLibrary.GetSeasons";
			MAKESTRING (Params$, 
			"{\x22tvshowid\x22:%d,\x22properties\x22:[%s],%s}"
								,TvShowID
								,"\x22season\x22"
								,"\x22sort\x22:{\x22method\x22:\x22label\x22,\x22order\x22:\x22ascending\x22}"
								);
 
			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETTVSEASONS, method, Params$);
			BREAK;
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
			method = "VideoLibrary.GetEpisodes"; 
 			Params$ = TvShowDetailsParameters(TvShowID, TvShowSeasonID, "episode");

			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETTVEPISODES, method, Params$);
			BREAK;
		}
		CASE (MUSIC_ALBUM_LIST)  : 
		{ 
			method = "AudioLibrary.GetAlbums"; 
			Params$ = AudioPlaylistParameters("", "label");

			CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_GETALBUMS, method, Params$);
			BREAK;
		}
		CASE (MUSIC_ARTIST_LIST)  : 
		{ 
			method = "AudioLibrary.GetArtists"; 
 			Params$ = ArtistsParameters("label");

			CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_GETARTISTS, method, Params$);
			BREAK;
		}
		CASE (MUSIC_ARTIST_CHOOSE_LIST)  : 
		{ 
			method = "AudioLibrary.GetAlbums"; 
			MAKESTRING(Params$, "\x22artistid\x22:%d,", ArtistID);
			Params$ = AudioPlaylistParameters(Params$, "label");

			CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_GETARTISTALBUMS, method, Params$);
			BREAK;
		}

		CASE (MUSIC_SONG_LIST)  : 
		{ 
			method = "AudioLibrary.GetSongs"; 
			IF (AlbumID)
			{
				MAKESTRING(Params$, "\x22albumid\x22:%d,", AlbumID);
				Params$ = AudioPlaylistParameters(Params$, "track");
			}
			ELSE IF (ArtistID)
			{
				MAKESTRING(Params$, "\x22artistid\x22:%d,", ArtistID);
				Params$ = AudioPlaylistParameters(Params$, "title");
			}
			ELSE
				Params$ = AudioPlaylistParameters(Params$, "title");
				
			CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_GETSONGS, method, Params$);
			BREAK;
		}
        DEFAULT: Print("XBMC.usp: (FUNCTION RepopulateOutputList): Invalid ListID (%d)", List_CurrentScreen);
	}
}

/*
     Store in memory the id's of the 'Play all' playlist
*/
FUNCTION GetPlayAllPlaylist()
{
	STRING Params$[150];

	NumberOfSongs = 0;

	IF (AlbumID)
		MAKESTRING(Params$, 
					"{\x22albumid\x22:%d,\x22properties\x22:[%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22track\x22%s", 
					AlbumID,"\x22title\x22","\x22album\x22","\x22duration\x22","\x22track\x22","\x7D\x7D" // MC3 bug fix
					);
	ELSE IF (ArtistID)
		MAKESTRING(Params$, 
					"{\x22artistid\x22:%d,\x22properties\x22:[%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22label\x22%s", 
					ArtistID, "\x22title\x22","\x22album\x22","\x22duration\x22","\x22track\x22","\x7D\x7D" // MC3 bug fix
					);
 
	#IF_DEFINED DEBUG          
		PRINT ("AudioLibrary.GetSongs: %s", Params$);
	#ENDIF

	CALL SendJsonCommand (REQUESTID_PLAYLIST_PLAYALLLIST, 
							"AudioLibrary.GetSongs", Params$);
	
}
 
/*
     Create a playlist on Xbmc using a JSON batch request ("[ {request1}, {request2},...]").
	 Called from FUNCTION Play().
*/
FUNCTION CreatePlaylistOnXbmc()
{
	INTEGER i;
	INTEGER NumberOfItems;
	STRING Command$[256];
	INTEGER CombinedLengthOfCommands;
	STRING JSONCommand$[BUFFER_SIZE];
	INTEGER ItemNumberZeroBased;
             
	NumberOfItems = 1;
	CombinedLengthOfCommands = 1;
     
	// Determine how long the Playlist is.
    WHILE (PlaylistIDs[NumberOfItems])	
	{
         NumberOfItems = NumberOfItems + 1;
	}
    NumberOfItems = NumberOfItems - 1;
    
	// Add the 'Playlist.Clear' command to the batch
	MAKESTRING (Command$, 
			"[{\x22id\x22:%d,%s,%s,\x22params\x22:{\x22playlistid\x22:%d%s,"
			,REQUESTID_PLAYLIST_CLEAR ,"\x22jsonrpc\x22:\x222.0\x22", "\x22method\x22:\x22Playlist.Clear\x22"
			, XBMC_ACTIVEPLAYER_AUDIO, "\x7D\x7D"); //23-09-12 Added MC3 bug fix

	SETSTRING(Command$, 1, JSONCommand$);
	CombinedLengthOfCommands = LEN(Command$);

	// Loop and add each song to the playlist
	FOR (i = 0 TO NumberOfItems-1)
	{
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,%s,%s,\x22params\x22:{\x22playlistid\x22:%d,\x22item\x22:{\x22songid\x22:%d%s"
			,100+i ,"\x22jsonrpc\x22:\x222.0\x22", "\x22method\x22:\x22Playlist.Add\x22"
			, XBMC_ACTIVEPLAYER_AUDIO, PlaylistIDs[i+1], "\x7D\x7D\x7D"); //23-09-12 Added MC3 bug fix

		       
		// Add individual command to larger batch command string
		SETSTRING(Command$, CombinedLengthOfCommands+1, JSONCommand$);		
		CombinedLengthOfCommands = CombinedLengthOfCommands + LEN(Command$);

		// Add comma		
		SETSTRING(",", CombinedLengthOfCommands+1, JSONCommand$);
		CombinedLengthOfCommands = CombinedLengthOfCommands + 1;
    }
       
	// Calculate playlist position number (the position that play starts from)
    ItemNumberZeroBased = SelectedItem-1+StepAmount*List_PageNumber;
	IF (ItemNumberZeroBased<0) ItemNumberZeroBased=0; 
	IF (ItemNumberZeroBased>(NumberOfSongs-1)) ItemNumberZeroBased=(NumberOfSongs-1); 

	// Add the 'Play' command to the batch
	MAKESTRING (Command$, 
			"{\x22id\x22:%d,%s,%s,\x22params\x22:{\x22item\x22:{\x22playlistid\x22:%d,\x22position\x22:%d%s"
			,REQUESTID_PLAYLIST_PLAY ,"\x22jsonrpc\x22:\x222.0\x22", "\x22method\x22:\x22Player.Open\x22"
			, XBMC_ACTIVEPLAYER_AUDIO, ItemNumberZeroBased, "\x7D\x7D\x7D"); //23-09-12 Added MC3 bug fix
  	SETSTRING(Command$, CombinedLengthOfCommands+1, JSONCommand$);		
	CombinedLengthOfCommands = CombinedLengthOfCommands + LEN(Command$);


	SETSTRING("]", CombinedLengthOfCommands+1, JSONCommand$);                
    
	BatchRequest = ON;
	SendToSocket(JSONCommand$);
	
}

/*
	Play the currently selected Movie, TV Episode or Album

	Albums are played from the song list screen
*/
FUNCTION Play()
{
    STRING Command$[256];
	STRING BatchCommand$[500];
	INTEGER CombinedLengthOfCommands;
	INTEGER PlayerID;
	STRING  ItemType$[20];

	CombinedLengthOfCommands = 0;

	SWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) :
		{
			MovieDetails = OFF;
            PlayerID = XBMC_ACTIVEPLAYER_VIDEO;
			ItemType$ = "movieid";
		}
		CASE (TV_EPISODE_LIST)  : 
		{
            PlayerID = XBMC_ACTIVEPLAYER_VIDEO;
			ItemType$ = "episodeid";
		}
		CASE (MUSIC_SONG_LIST)  : 
		{          			
            PlayerID = XBMC_ACTIVEPLAYER_AUDIO;
			ItemType$ = "songid";

            IF (AlbumID || ArtistID)
            {
				CreatePlaylistOnXbmc();
	                 
				WaitforSocketToClear();

			    // Wait 3 seconds before requesting metadata
				WAIT(300)
				{
					PULSE(10, CheckCurrentlyPlaying);
				}
				RETURN; // Exit function
			}			
		}
	}
    
	SETSTRING("[", 1, BatchCommand$);
	CombinedLengthOfCommands = 1;

	// Add the 'Playlist.Clear' command to the batch: Clear any existing tracks.
	MAKESTRING (Command$, 
			"{\x22id\x22:%d,%s,%s,\x22params\x22:{\x22playlistid\x22:%d%s,"
			,REQUESTID_PLAYLIST_CLEAR ,"\x22jsonrpc\x22:\x222.0\x22", "\x22method\x22:\x22Playlist.Clear\x22"
			, XBMC_ACTIVEPLAYER_AUDIO, "\x7D\x7D"); //23-09-12 Added MC3 bug fix
	SETSTRING(Command$, CombinedLengthOfCommands+1, BatchCommand$);
	CombinedLengthOfCommands = CombinedLengthOfCommands+LEN(Command$);
	MAKESTRING (Command$, 
			"{\x22id\x22:%d,%s,%s,\x22params\x22:{\x22playlistid\x22:%d%s,"
			,REQUESTID_PLAYLIST_CLEAR+50 ,"\x22jsonrpc\x22:\x222.0\x22", "\x22method\x22:\x22Playlist.Clear\x22"
			, XBMC_ACTIVEPLAYER_VIDEO, "\x7D\x7D"); //23-09-12 Added MC3 bug fix
	SETSTRING(Command$, CombinedLengthOfCommands+1, BatchCommand$);
	CombinedLengthOfCommands = CombinedLengthOfCommands+LEN(Command$);


	// Add the 'Playlist.Add' command to the batch: This adds the id of the movie/episode/song to the playlist
	MAKESTRING (Command$, 
			"{\x22id\x22:%d,%s,%s,\x22params\x22:{\x22playlistid\x22:%d,\x22item\x22:{\x22%s\x22:%d%s,"
			,REQUESTID_PLAYLIST_ADD ,"\x22jsonrpc\x22:\x222.0\x22", "\x22method\x22:\x22Playlist.Add\x22"
			, PlayerID, ItemType$, List_IDs[SelectedItem], "\x7D\x7D\x7D"); //23-09-12 Added MC3 bug fix
	SETSTRING(Command$, CombinedLengthOfCommands+1, BatchCommand$);
	CombinedLengthOfCommands = CombinedLengthOfCommands+LEN(Command$);

	// Add the 'Playlist.Open' command to the batch
	MAKESTRING (Command$, 
			"{\x22id\x22:%d,%s,%s,\x22params\x22:{\x22item\x22:{\x22playlistid\x22:%d,\x22position\x22:%d%s"
			,REQUESTID_PLAYLIST_PLAY ,"\x22jsonrpc\x22:\x222.0\x22", "\x22method\x22:\x22Player.Open\x22"
			, PlayerID, 0, "\x7D\x7D\x7D"); //23-09-12 Added MC3 bug fix
	SETSTRING(Command$, CombinedLengthOfCommands+1, BatchCommand$);
	CombinedLengthOfCommands = CombinedLengthOfCommands+LEN(Command$);

	SETSTRING("]", CombinedLengthOfCommands+1, BatchCommand$);

	// don't send anything if the socket isn't open
	IF (IsConnected = OFF)
		RETURN;

	// don't send anything if a long running query is already in progress
	IF (Loading = ON)
		RETURN;
     
	// If the Socket is busy then set a flag to get control of it
	WHILE (SocketBusy)
	{
    	Loading = ON;
		Delay(1);
	}

    Print("%s", LEFT(BatchCommand$,100));
    Print("%s", RIGHT(BatchCommand$,100));


	// Send out the command in chunks
	WHILE (LEN(BatchCommand$))
	{
		Loading = ON;
		SocketBusy = ON;
		BatchRequest = ON;

		IF (LEN(BatchCommand$)>250)
		{
			// Send to socket in chunks
			SocketSend(XBMC, REMOVEBYLENGTH(250, BatchCommand$));
		}
		ELSE
		{
			// send last chunk
			SocketSend(XBMC, BatchCommand$);
			BatchCommand$ = "";
		}
	}


    // Wait 3 seconds before requesting metadata
	WAIT(300)
	{
		PULSE(10, CheckCurrentlyPlaying);
	}
}

 
/********************************************************************************
*
* EVENT handlers
*
********************************************************************************/
/*
  	Play the selected item
*/
CHANGE PlayItem
{
	Play();

	MovieDetails = OFF;
    TvShowDetails = OFF;
}

/*
  	The given item has been selected from a list
*/
CHANGE SelectedItem
{

	CSWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) : 
		{
			GetMovieDetails(List_IDs[SelectedItem]);
			MovieDetails = ON;
			Break;
		}
		CASE (TV_SHOW_LIST) 	: 
		{
			SelectedSeriesName$ =    TvShows[List_Position[SelectedItem]].label;  
            SelectedGenre$      =    TvShows[List_Position[SelectedItem]].genre;
			SelectedYear$       =    TvShows[List_Position[SelectedItem]].year;

	        List_CurrentScreen = TV_SEASON_LIST;
			OldShowListPage = List_PageNumber;
			TvShowID = List_IDs[SelectedItem];
			List_PageNumber = 0;
			List_Total = 0;
			NumberOfTvShowSeasons = 0;
			RepopulateMediaList();
			IsTvShowList = OFF;
			Break;
		}
		CASE (TV_SEASON_LIST) 	: 
		{
			IF (List_IDs[SelectedItem])
			{
		        List_CurrentScreen = TV_EPISODE_LIST;
				OldSeasonListPage = List_PageNumber;

				IF (List_IDs[SelectedItem] = SPECIAL_SEASON)
					TvShowSeasonID = 0;
				else				
					TvShowSeasonID = List_IDs[SelectedItem];

				List_PageNumber = 0;
				List_Total = 0;
				NumberOfTvShowEpisodes = 0;
				RepopulateMediaList();		
			}
			Break;
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
			IF (List_IDs[SelectedItem])
			{
				GetEpisodeDetails(List_IDs[SelectedItem]);
    	    	TvShowDetails = ON;	
	    		MovieDetails = OFF;
			}
			Break;
		}
		CASE (MUSIC_ALBUM_LIST) : 
		{ 
	        List_CurrentScreen = MUSIC_SONG_LIST;
			OldAlbumListPage = List_PageNumber;
			AlbumID = List_IDs[SelectedItem];
			ArtistID = 0;
			List_PageNumber = 0;
			List_Total = 0;
			IsAlbumList = OFF;
			IsSongList = ON;
             
			Initialize_OutputArrays();

			GetPlayAllPlaylist();
			Break;
		}
		CASE (MUSIC_ARTIST_LIST) : 
		{ 
	        List_CurrentScreen = MUSIC_ARTIST_CHOOSE_LIST;
			OldArtistListPage = List_PageNumber;
			AlbumID = 0;
			ArtistID = List_IDs[SelectedItem];
			List_PageNumber = 0;
			List_Total = 0;
			IsSongList = OFF;
			IsArtistList = OFF;
			IsAlbumList = ON;
			NumberOfArtistAlbums = 0;
			RepopulateMediaList();
			Break;
		}
		CASE (MUSIC_ARTIST_CHOOSE_LIST) : 
		{ 
			List_CurrentScreen = MUSIC_SONG_LIST;
			List_PageNumber = 0;
			List_Total = 0;
			IsAlbumList = OFF;
			IsSongList = ON;
			NumberOfSongs = 0;
		
			// If albumID = 0 then 'All songs' has been selected
			AlbumID = List_IDs[SelectedItem];		
             
			Initialize_OutputArrays();
			GetPlayAllPlaylist();
		
			Break;
		}
		CASE (MUSIC_SONG_LIST)  : 
		{ 
			Play();
			Break;
		}

        DEFAULT: 
		{
			// do Nothing			
		}
	}
}
 
/*
  	The 'BACK' button has been pressed while browsing a list
	->	Go to the previous list screen (e.g. From TV Episode list to Season list)
*/
PUSH List_Back
{
	SWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST)					: 
		{
			MovieDetails = OFF;
			TERMINATEEVENT;	// don't need to reload current list values;
		}
		CASE (TV_SEASON_LIST) 	: 
		{
			List_PageNumber = OldShowListPage;
			List_CurrentScreen = TV_SHOW_LIST;
			List_Total = NumberOfTvShows;
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
			List_CurrentScreen = TV_SEASON_LIST;
			TvShowDetails = OFF; // Just in case
			List_PageNumber = 0;
			List_Total = 0;
			NumberOfTvShowSeasons = 0;
			RepopulateMediaList();
			TERMINATEEVENT;
		}
		CASE (MUSIC_ARTIST_CHOOSE_LIST) : 
		{ 
            List_PageNumber = OldArtistListPage;
			List_CurrentScreen = MUSIC_ARTIST_LIST;
			IsSongList = OFF;
			IsArtistList = ON;
			IsAlbumList = OFF;
			List_Total = NumberOfArtists;
		}
		CASE (MUSIC_SONG_LIST)  : 
		{
			IF (AlbumID && ArtistID)
			{
	            List_PageNumber = 0;
				List_CurrentScreen = MUSIC_ARTIST_CHOOSE_LIST;
				List_Total = NumberOfArtistAlbums;
				IsSongList = OFF;
				IsArtistList = OFF;
				IsAlbumList = ON;
			}
			ELSE IF (ArtistID)
			{
	            List_PageNumber = OldArtistListPage;
				List_CurrentScreen = MUSIC_ARTIST_CHOOSE_LIST;
				List_Total = NumberOfArtistAlbums;
				IsSongList = OFF;
				IsArtistList = ON;
				IsAlbumList = OFF;
			}
			ELSE IF (AlbumID)
			{
	            List_PageNumber = OldAlbumListPage;
				List_CurrentScreen = MUSIC_ALBUM_LIST;
				List_Total = NumberOfAlbums;
				IsSongList = OFF;
				IsArtistList = OFF;
				IsAlbumList = ON;
			}
            ELSE
				List_PageNumber = 0;
		}
        DEFAULT: 
		{
			List_PageNumber = 0;			
		}
	}

	CALL RepopulateOutputList(0);

}

/*
  	The 'TopPage' button has been pressed while browsing a list:
	->	Go to the first page
*/
PUSH List_TopPage
{
	List_PageNumber = 0;

	CALL RepopulateOutputList(0);
}
/*
  	The 'BottomPage' button has been pressed while browsing a list:
	->	Go to the last page
*/
PUSH List_BottomPage
{
	IF (List_Total)
        List_PageNumber = (List_Total - (List_Total MOD StepAmount)) / StepAmount;
	ELSE
		List_PageNumber = 0;

	CALL RepopulateOutputList(0);
}
/*
  	The 'PageMinus' button has been pressed while browsing a list:
	->	Go to the previous page
*/
PUSH List_PageMinus
{ 	
	IF (List_PageNumber) 
	{
		List_PageNumber = List_PageNumber - 1;

		CALL RepopulateOutputList(0);
	}
}
/*
  	The 'PagePlus' button has been pressed while browsing a list:
	->	Go to the next page
*/
PUSH List_PagePlus
{
	List_PageNumber = List_PageNumber + 1;                                  

	IF (List_Total)
	{
		IF (List_PageNumber*StepAmount > List_Total)
		{
         	List_PageNumber = (List_Total - (List_Total MOD StepAmount)) / StepAmount;
		}
	}

	CALL RepopulateOutputList(0);
}

PUSH List_Movies
{

	List_CurrentScreen = MOVIE_TITLE_LIST;
    IsMovieList = ON;
	IsTvShowList = OFF;
	IsAlbumList = OFF;
	IsArtistList = OFF;
	IsSongList = OFF;
    TvShowDetails = OFF;	
   	MovieDetails = OFF;
	List_Summary$ = "";

	List_PageNumber = 0;
	List_Total = CurrentMovieNumber;
    
	IF (CurrentMovieNumber)                            
		CALL RepopulateOutputList(0);
    ELSE		
		CALL RepopulateMediaList();

}

PUSH List_TvShows
{
	List_CurrentScreen = TV_SHOW_LIST;
    IsMovieList = OFF;
	IsTvShowList = ON;
	IsAlbumList = OFF;
	IsArtistList = OFF;
	IsSongList = OFF;
    TvShowDetails = OFF;	
   	MovieDetails = OFF;
	List_Summary$ = "";

	List_PageNumber = 0;
	List_Total = CurrentTvShowNumber;

	IF (CurrentTvShowNumber)                            
		CALL RepopulateOutputList(0);
    ELSE		
		CALL RepopulateMediaList();
}

PUSH List_Albums
{
	List_CurrentScreen = MUSIC_ALBUM_LIST;
    IsMovieList = OFF;
	IsTvShowList = OFF;
	IsAlbumList = ON;
	IsArtistList = OFF;
	IsSongList = OFF;
	List_Summary$ = "";

	List_PageNumber = 0;
	List_Total = CurrentAlbumNumber;
	ArtistID = 0;
    
	IF (CurrentAlbumNumber)
		CALL RepopulateOutputList(0);
    ELSE		
		CALL RepopulateMediaList();
}

PUSH List_Artists
{
	List_CurrentScreen = MUSIC_ARTIST_LIST;
    IsMovieList = OFF;
	IsTvShowList = OFF;
	IsAlbumList = OFF;
	IsArtistList = ON;
	IsSongList = OFF;
	List_Summary$ = "";

	List_PageNumber = 0;
	List_Total = CurrentArtistNumber;
	AlbumID = 0;
    
	IF (CurrentArtistNumber)
		CALL RepopulateOutputList(0);
    ELSE		
		CALL RepopulateMediaList();
}

PUSH List_Songs
{
	List_CurrentScreen = MUSIC_SONG_LIST;
    IsMovieList = OFF;
	IsTvShowList = OFF;
	IsAlbumList = OFF;
	IsArtistList = OFF;
	IsSongList = ON;
    TvShowDetails = OFF;	
   	MovieDetails = OFF;
	List_Summary$ = "";

	List_PageNumber = 0;
	List_Total = 0;
	AlbumID = 0;
	ArtistID = 0;
      
	// disable for now... takes too long.
	//CALL RepopulateOutputList(0);
}

PUSH List_Exit_Details_Page
{
	TvShowDetails = OFF;	
   	MovieDetails = OFF;
}
 

CHANGE SearchCriteria$
{
	STRING Search$[256];
	INTEGER FirstCharacter;
	INTEGER i;
           
	IF (LEN(SearchCriteria$))
	{
		Search$ = RemoveByLength(LEN(SearchCriteria$),SearchCriteria$);
		#IF_DEFINED DEBUG
			PRINT("Search: %s (length:%d)", Search$, LEN(Search$));
		#ENDIF

		SWITCH (List_CurrentScreen)
		{
			CASE (MOVIE_TITLE_LIST) : 
			{ 
				IF (CurrentMovieNumber)
				{
					FOR (i = 1 TO NumberOfMovies)
					{
                    	IF (CompareStringsNoCase(Movies[i].label, Search$) >= 0)
						{
							CALL RepopulateOutputList(i);
                        	Break;
						}
					}
				}
			}
			CASE (TV_SHOW_LIST)		: 
			{ 
				IF (CurrentTvShowNumber)
				{
					FOR (i = 1 TO NumberOfTvShows)
					{
                    	IF (CompareStringsNoCase(TvShows[i].label, Search$) >= 0)
						{
							CALL RepopulateOutputList(i);
                        	Break;
						}
					}
				}

			}
			CASE (TV_SEASON_LIST) 	: { }
			CASE (TV_EPISODE_LIST)  : { }
			CASE (MUSIC_SONG_LIST)  :
			{ 
			}
			CASE (MUSIC_ARTIST_LIST)  : 
			{
				IF (CurrentArtistNumber)
				{
					FOR (i = 1 TO NumberOfArtists)
					{
						// Exclude case where name begins with an Extended ASCII character
						FirstCharacter = BYTE(Artists[i].label,1);
						IF (FirstCharacter < 127)
	                    	IF (CompareStringsNoCase(Artists[i].label, Search$) >= 0)
							{
								CALL RepopulateOutputList(i);
	                        	Break;
							}
					}
				}

			}
			CASE (MUSIC_ALBUM_LIST)  : 
			{
				IF (CurrentAlbumNumber)
				{
					FOR (i = 1 TO NumberOfAlbums)
					{						
						// Exclude case where name begins with an Extended ASCII character
						FirstCharacter = BYTE(Albums[i].label,1);
						IF (FirstCharacter < 127)
		                   	IF (CompareStringsNoCase(Albums[i].label, Search$) >= 0)
							{
								CALL RepopulateOutputList(i);
                	        	Break;
							}
					}
				}

			}
	    }

	}
} 

PUSH Connect
{
	// connect to XBMC
	ConnectToXbmc();

}
RELEASE Connect
{
 	// disconnect from XBMC
	DisconnectFromXbmc();
}

/*
  	A JSON command has been received from Xbmc.usp
	-> Send it to the xbmc socket
*/
CHANGE Tx$
{
	STRING Command$[1000];
    
	// Test for empty buffer (Can happen if buffer emptied by earlier event)
	IF (LEN(Tx$) = 0) 
	{
		TERMINATEEVENT;
	}

	Command$ = GATHER("\n", Tx$, GATHER_TIMEOUT);
    
    IF (SocketBusy || Loading)
	{
		#IF_DEFINED DEBUG PRINT("Quitting Command: %s" ,LEFT(Command$,50)); #ENDIF

    	TERMINATEEVENT; //Be Harsh, can't risk cross threading mixup with long-running Browse queries
    }
	ELSE
    { 
		SocketBusy = ON;
		ExternalRequest = ON;
		SocketSend(XBMC, Command$);
	}
}



///////////// Initialization script
Function Main()
{              
	STRING Xbmc$[BUFFER_SIZE];
              
	WaitForInitializationComplete();
                         
    // Eternal loop, waiting for Data from Xbmc 
	WHILE(1)
	{
		// Wait for a minimum of 10 bytes
		// Can't use a delimiter because with JSON there isn't one.
  		Xbmc$ = GatherByLength(MAX(10,LEN(XBMC.SocketRxBuf)), XBMC.SocketRxBuf);
		CALL ProcessResponse(Xbmc$);		
	} 

}
