/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name: XBMC
System Number: 1.0
Programmer: Neil Carthy (arduino@scpgwiki.com)
Comments:                                             
    
	***** License *****

	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#SYMBOL_NAME "XBMC-Browse"
#CATEGORY "41" // Remote System Interface
#HINT "Browse/search the XBMC catalogs for video and music."  


/////////////////////Compiler Directives
#PRINT_TO_TRACE
#ENABLE_DYNAMIC
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#OUTPUT_SHIFT 7			// Shift the outputs down 7 lines on the SIMPL window

#USER_LIBRARY "Common_Functions"

/*****    DEFINE NEW CONSTANTS    *******/
//#DEFINE_CONSTANT DEBUG 1              // Uncomment this to see debug messages
#DEFINE_CONSTANT JSON_DELAY 	30		// Delay between JSON calls in 1/100th of second
#DEFINE_CONSTANT GATHER_TIMEOUT 1000    // 10 seconds
                                                      
/* Types of List */ 
#DEFINE_CONSTANT MOVIE_TITLE_LIST					 1
#DEFINE_CONSTANT TV_SHOW_LIST                        2 
#DEFINE_CONSTANT TV_SEASON_LIST                      3 
#DEFINE_CONSTANT TV_EPISODE_LIST                     4
#DEFINE_CONSTANT MUSIC_ARTIST_LIST                   5
#DEFINE_CONSTANT MUSIC_ALBUM_LIST                    6
#DEFINE_CONSTANT MUSIC_SONG_LIST                     7  
                   
/* REequest IDs for different JSON-RPC commands */
#DEFINE_CONSTANT REQUESTID_GETACTIVEPLAYERS				1
#DEFINE_CONSTANT REQUESTID_GETINFOLABELS				2
#DEFINE_CONSTANT REQUESTID_AUDIOPLAYLIST_GETITEMS		3
#DEFINE_CONSTANT REQUESTID_VIDEOPLAYLIST_GETITEMS		4
#DEFINE_CONSTANT REQUESTID_GETTIME_SECONDS				5
#DEFINE_CONSTANT REQUESTID_GETTIME_PERCENTAGE			6
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETMOVIES		7
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVSHOWS		8
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVSEASONS	9
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVEPISODES	10
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETARTISTS		11
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETALBUMS		12
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETSONGS		13
#DEFINE_CONSTANT REQUESTID_PLAYLIST_CLEAR				14
#DEFINE_CONSTANT REQUESTID_PLAYLIST_ADD					15
#DEFINE_CONSTANT REQUESTID_PLAYLIST_PLAY				16
#DEFINE_CONSTANT REQUESTID_PLAYLIST_PLAYALLLIST			17
                                                          

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
DIGITAL_OUTPUT  MovieDetails,
                TvShowDetails,
				MusicDetails,
				_SKIP_,
				SearchAvailable,
				_SKIP_,
				IsMovieList,
				IsAlbumList,
				IsTvShowList,
				IsArtistList,
				IsSongList,
				_SKIP_,
				CheckCurrentlyPlaying, // Tell XBMC.usp to update the currently-playing metadata
				ClearCurrentlyPlaying; // Tell XBMC.usp to clear the currently-playing metadata

DIGITAL_OUTPUT _SKIP_, Watched[10];		// HIGH when item has already been watched.
                 	
STRING_OUTPUT 	_SKIP_,
				PlotSelected$,					// The plot of the selected movie or TV showList_Summary$,					// e.g. 7 to 12 of 15
				_SKIP_,
				List_Summary$,					// e.g. 7 to 12 of 15
				_SKIP_,
				Tx$,							// Json Command to XBMC (delimited by "\n")		
				_SKIP_;   

ANALOG_OUTPUT   List_CurrentScreen;		// 1 = Movies list, 2 = TV show list, 3 = TV season list etc.

STRING_OUTPUT _SKIP_,Name$[10],
				Year$[10],
				Genre$[10],
				Rating$[10],
				Runtime$[10],
				Director$[10],
				Tagline$[10],
				Thumb$[10],
				Writer$[10],
				EpisodeOrTrackNum$[10],
				SeasonOrAlbumName$[10],
				Studio$[10],
				MPAA$[10],
				SeriesOrArtistName$[10],
				Fanart$[10];
				

/* Browse functionality */
DIGITAL_INPUT   _SKIP_,_SKIP_,_SKIP_,_SKIP_,_SKIP_,_SKIP_,_SKIP_,				
				List_UnWatchedOnly,
				List_TopPage,
				List_BottomPage,
				List_PageMinus,
				List_PagePlus,
				List_Back,
				List_Movies,
				List_Albums,
				List_TVShows, 
				List_Artists,
				List_Songs,
				List_Exit_Details_Page,
				_SKIP_;

DIGITAL_INPUT SocketIsBusy, _SKIP_; // HIGH when a JSON command is being transmitted;

ANALOG_INPUT PlayItem, SelectedItem;
ANALOG_INPUT PlotItem;						// The index of the plot array

STRING_INPUT _SKIP_, SearchCriteria$[256], _SKIP_;	
BUFFER_INPUT Rx$[65534];					// The reply from XBMC

///////////////////////////// Parameters
STRING_PARAMETER XBMC_IPAddr$[16];   //the ip of the XBMC server.
STRING_PARAMETER XBMC_Port$[5];		 //the port that the XBMC server lives on
INTEGER_PARAMETER StepAmount;		 // Only return this many results from database at a time
INTEGER_PARAMETER UseJpgExtension;	 // Use '.jpg' as thumbnail extension instead of '.tbn'
STRING_PARAMETER LOGIN[30];			 // Username for http server (used to downlaod thumbnails) 
STRING_PARAMETER PASSWORD[30];		 // Password for http server (used to downlaod thumbnails)

/*******************************************************************************************
  Parameter Properties
  (Uncomment and declare parameter properties as needed)
*******************************************************************************************/
#BEGIN_PARAMETER_PROPERTIES XBMC_IPAddr$ 
    propDefaultValue = "";  
    propShortDescription = "The IP Address of the XBMC HTTP server.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES XBMC_Port$
   propDefaultValue = "";   
   propShortDescription = "The port that the XBMC HTTP server is listening on. (NOT the tcp server)";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES StepAmount
	propValidUnits = unitDecimal;
    propDefaultUnit = unitDecimal;
    propDefaultValue = 10d;
    propShortDescription = "Only return this many results from database at a time.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES UseJpgExtension
	propValidUnits = unitDecimal;
    propDefaultUnit = unitDecimal;
    propDefaultValue = 0d;
    propShortDescription = "Use jpg as thumbnail extension instead of tbn";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES LOGIN
   propDefaultValue = "xbmc";   
   propShortDescription = "Login for HTTP Basic Authentication. Set 0d if no login. Max 30 chars.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES PASSWORD
   propDefaultValue = "xbmc";   
   propShortDescription = "Password for HTTP Basic Authentication. Set 0d if no password. Max 30 chars.";
#END_PARAMETER_PROPERTIES

/////////////////////////// Global Variables
//STRING CoverArtInternal$[512];					   // Uri of coverart thumb. Stored internally so that
												   // a comparison can be made. This is b'cos the TPS-6X
												   // is easily overloaded by dynamic graphic calls.
INTEGER PlaylistPosition;						   // The (zero-based) number of the track in the current playlist
INTEGER ActivePlayer;							   // 1 = audio, 2 = slideshow, 4 = video
INTEGER List_PageNumber;						   // The (zero-based) current page number of the list;
INTEGER List_Total;								   // The total number of items in the current browse list
STRING List_Filename$[10][1024];				   // The filenames of all the items in the current list
INTEGER List_IDs[10];							   // The ids of the items in the browse list
INTEGER SeasonNumber[10];						   // The number of the TV show seasons listed
INTEGER OldShowListPage,OldSeasonListPage,OldArtistListPage,OldAlbumListPage;
INTEGER TvShowID, TvShowSeasonID, TvShowEpisodeID, AlbumID, ArtistID;
INTEGER PlaylistIDs[100];						   // The songids/movieids etc. of the current playlist
STRING List_Plot$[10][1024];						   // An internal store of the Plot (which is a long string)
												   // done this way to circumvent limitation on length of
												   // indirect text to VT-Pro-e programs
INTEGER TCPBlocker;					// Semaphore for incomplete JSON packets. A packet is not complete
									// until we receive the '<EOF>' tag.
SIGNED_INTEGER PlaySpeed;			// Speed of current audio/video playback (1x, 2x, 4x etc.)
INTEGER IsTvShow;
INTEGER IsPlaying;


/*******************************************************************************************
  XBMC Response logic
*******************************************************************************************/
/*
  	Return a string containing the xbmc parameter list for Video Playlists
*/
STRING_FUNCTION VideoPlaylistParameters(STRING AdditionalParameters, INTEGER start, INTEGER end
											,STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{%s\x22fields\x22:[%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22},\x22start\x22:%d,\x22end\x22:%d}"
								, AdditionalParameters
								,"\x22title\x22"
								,"\x22originaltitle\x22"
								,"\x22director\x22"
								,"\x22tagline\x22"
								,"\x22genre\x22"
								,"\x22showtitle\x22"
								,"\x22runtime\x22"
								,"\x22year\x22"
								,"\x22rating\x22"
								,"\x22writer\x22"
								,"\x22studio\x22"
								//,"\x22plotoutline\x22"
								,"\x22plot\x22"
								,"\x22season\x22"
								,"\x22episode\x22"
								,"\x22firstaired\x22"
								,"\x22studio\x22"
								,"\x22mpaa\x22"
								,"\x22playcount\x22"
								,SortMethod
								,start
								,end 
					);
 
	#IF_DEFINED DEBUG PRINT( "VideoPlaylistParameters:%s", LEFT(Params$,200)  ); #ENDIF

	RETURN (Params$);
}
/*
  	Return a string containing the xbmc parameter list for Audio Playlists
*/
STRING_FUNCTION AudioPlaylistParameters(STRING AdditionalParameters, INTEGER start, INTEGER end
											,STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{%s\x22fields\x22:[%s,%s,%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22},\x22start\x22:%d,\x22end\x22:%d}"
								, AdditionalParameters
								,"\x22title\x22"
								,"\x22artist\x22"
								,"\x22album\x22"
								,"\x22genre\x22"
								,"\x22year\x22"
								,"\x22rating\x22"
								,"\x22duration\x22"
								,"\x22tracknumber\x22"
								,SortMethod
								,start
								,end 
					);
	#IF_DEFINED DEBUG PRINT( "AudioPlaylistParameters:%s", LEFT(Params$,200)  ); #ENDIF

	RETURN (Params$);
}

/*
    Take the uri given by XBMC and add http://, ip_address, port etc.
	When UseJPG = 1, Use the extension '.jpg' instead of '.tbn'.
*/
STRING_FUNCTION ThumbnailUri(STRING uri$, INTEGER UseJPG)
{
	STRING tmpCoverPath[512];
	IF(LOGIN <> "0d" && PASSWORD <> "0d"){
		tmpCoverPath = "http://" + LOGIN + ":" + PASSWORD + "@" + XBMC_IPAddr$ + ":"+ XBMC_Port$ + "/";
	}	
	ELSE{
		tmpCoverPath = "http://" + XBMC_IPAddr$ + ":"+ XBMC_Port$ + "/";
	}
	IF (UseJPG)
		tmpCoverPath = tmpCoverPath + "vfs:" + LEFT(uri$, LEN(uri$) - 4) + ".jpg";
	ELSE
		tmpCoverPath = tmpCoverPath + "vfs:" + uri$;
    RETURN (tmpCoverPath);
}

/*
    Send the plot string (usu very long) to a STRING_OUTPUT
	Done this way to overcome length restriction on Indirect Text joins
*/
FUNCTION SendPlotAsIndirectText(STRING longstring$)
{
	STRING chunk[100];	
	STRING Original$[1024];
     
	#IF_DEFINED DEBUG PRINT( "plot Length: %d", len(longstring$)  ); #ENDIF

	Original$ = longstring$;

	// Must reset the output string.
    PlotSelected$ = "";

	while (len(longstring$))
	{
		if (len(longstring$)>100)
		{
			chunk = removebylength(100, longstring$);
		}
		else
		{
			chunk = longstring$;
			longstring$ = "";
		}
		PlotSelected$ = "\xFE\x02" + chunk;
	}	

	longstring$ = Original$;
}


/*
	Set the output arrays to a default empty state
*/
FUNCTION Initialize_OutputArrays()
{
	INTEGER i;
	FOR (I = 1 TO 10)
	{
     	Name$[i] = "";
		Year$[i] = "";
		Genre$[i] = "";
		Rating$[i] = "";
		Runtime$[i] = "";
		Director$[i] = "";
		Tagline$[i] = "";
		Thumb$[i] = "";
		Writer$[i] = "";
		EpisodeOrTrackNum$[i] = "";
		SeasonOrAlbumName$[i] = "";
		Studio$[i] = "";
		MPAA$[i] = "";
		SeriesOrArtistName$[i] = "";
		Fanart$[i] = "";
		List_Plot$[i] = "";
		Watched[i] = OFF;
	}

	PlotSelected$ = "";
}

/*

*/
FUNCTION GetPlayAllPlaylistFromResponse(STRING Array$, STRING ID_Identifier)
{
    INTEGER IdentifierIndex;
	INTEGER ColonIndex;
	INTEGER CommaIndex;
	STRING ID$[10];
	INTEGER I,J;

	I=0; J=0;

	IdentifierIndex = Find(ID_Identifier, Array$);

	WHILE (IdentifierIndex)
	{
    	ColonIndex = FIND(":", Array$, IdentifierIndex);
		IF (ColonIndex)
		{
			CommaIndex = FIND(",", Array$, ColonIndex);
			IF (CommaIndex)
			{
	            ID$ = RemoveDoubleQuotesAndWhitespace( Mid(Array$, ColonIndex+1, CommaIndex-ColonIndex-1) );
                #IF_DEFINED DEBUG PRINT("ID$: %s", ID$); #ENDIF
				PlaylistIDs[I] = AtoI(ID$);
			}
		}

		IdentifierIndex = Find(ID_Identifier, Array$, IdentifierIndex+10);
		I = I+1;
                    
		// Bailout
		IF (I = 101)
			IdentifierIndex = 0;
	}

	FOR (J=I TO 100)
	{
         PlaylistIDs[J]=0;
	}
}


/*
    Update outputs using response from a JSON call that returned an array

	Item$:			The JSON description of the Item		
*/
FUNCTION UpdateOutputsFromBrowseList(STRING Array$)
{
	INTEGER Ind[2];					//Index variables used to parse the reponse
	STRING Info[40][400];			//An array of currently playing information
	STRING Category[40][40];		//An array of the type of Info e.g. Genre, Artist etc.	  
	INTEGER i,j;					//Loop vars
	INTEGER ItemNumber;    			// The index of the current list item
	INTEGER ItemStart;				// The first character of the current item.
	INTEGER ItemEnd;				// The last character of the current item.

	ItemNumber=1; Ind[0] = 1; 
	ItemStart = 0; ItemEnd = 0;
	i=0;j=0;

	WHILE ( ItemNumber <= StepAmount && (ItemNumber+StepAmount*List_PageNumber) <= List_Total)
    {
		ItemStart = Find("{", Array$, ItemEnd)+1;
		Ind[0] = Find("\x22", Array$, ItemStart);
		i=0; j=0;

		ItemEnd = Find("},\x0A", Array$, ItemStart);
		IF (ItemEnd=0) ItemEnd = LEN(Array$);

		// Parse the JSON items list into an array of Info & Categories
		While(Ind[0])
		{
			Ind[1] = Find(": ", Array$, Ind[0]);
			If(Ind[1] && Ind[1]<ItemEnd)
			{
	
				Ind[2] = Find(",\x0A", Array$, Ind[1]); // Each list item is separated by a comma, followed by a line-feed
				IF ( Ind[2] > ItemEnd || Ind[2] = 0) 
					Ind[2] = Find("}", Array$, Ind[1])-1; // must be the end of the list
				
				Category[j] = RemoveDoubleQuotesAndWhitespace( Mid(Array$, Ind[0]+1, Ind[1]-Ind[0]-1) );
				
				IF (Category[j] = "plot")
				{
                    List_Plot$[ItemNumber] = LEFT(RemoveDoubleQuotesAndWhitespace( Mid(Array$, Ind[1]+1, Ind[2]-Ind[1]-1) ), 1024); 
					Info[j] = "";
				}
				ELSE
					Info[j] = LEFT(RemoveDoubleQuotesAndWhitespace( Mid(Array$, Ind[1]+1, Ind[2]-Ind[1]-1) ), 400); 
	
				#IF_DEFINED DEBUG 
					PRINT( "%s: %s\n", Category[j], LEFT(Info[j],220)  ); 
				#ENDIF
	
				j=j+1;
				
				Ind[0] = Ind[2];
	
				// Emergency bailout
				IF (j > 38) Ind[0] = 0;
	
			}
			Else Ind[0] = 0;
		} 

		// Assign to OUTPUTs
		FOR (i = 0 to j-1)
		{
	     	IF (Category[i] = "file") List_Filename$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "title") Name$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "label") Name$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "movieid") 
			{
				IF (List_CurrentScreen = MOVIE_TITLE_LIST)
					List_IDs[ItemNumber] = AtoI(Info[i]);
			}
			ELSE IF(Category[i] = "tvshowid") 
			{
				IF (List_CurrentScreen = TV_SHOW_LIST)
					List_IDs[ItemNumber] = AtoI(Info[i]);
			}
            ELSE IF(Category[i] = "episodeid")
			{
				IF (List_CurrentScreen = TV_EPISODE_LIST)
			 		List_IDs[ItemNumber] = AtoI(Info[i]);
			}
			ELSE IF(Category[i] = "albumid") List_IDs[ItemNumber] = AtoI(Info[i]);
			ELSE IF(Category[i] = "artistid") List_IDs[ItemNumber] = AtoI(Info[i]);
			ELSE IF(Category[i] = "songid") List_IDs[ItemNumber] = AtoI(Info[i]);
			ELSE IF(Category[i] = "season") 
			{
				IF (List_CurrentScreen = TV_SEASON_LIST) List_IDs[ItemNumber] = AtoI(Info[i]);
				SeasonOrAlbumName$[ItemNumber] = "Season " + Info[i];
			}
			ELSE IF(Category[i] = "artist") SeriesOrArtistName$[ItemNumber] = Info[i];
	 		ELSE IF(Category[i] = "album") SeasonOrAlbumName$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "genre") Genre$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "director") Director$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "year") Year$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "runtime") Runtime$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "duration") Runtime$[ItemNumber] = ConvertToTime(AtoI(Info[i]));
			ELSE IF(Category[i] = "rating") Rating$[ItemNumber] = Round(Info[i],2);		
	        ELSE IF(Category[i] = "studio") Studio$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "writer") Writer$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "plot") ; // Do Nothing, handled in section above as special case.
			ELSE IF(Category[i] = "showtitle") SeriesOrArtistName$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "episode") EpisodeOrTrackNum$[ItemNumber] = "Episode "+Info[i];
			ELSE IF(Category[i] = "tracknumber") EpisodeOrTrackNum$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "firstaired") TagLine$[ItemNumber] = "First aired on: "+Info[i];
			ELSE IF(Category[i] = "tagline") TagLine$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "mpaa") MPAA$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "mpaa") MPAA$[ItemNumber] = Info[i];
			ELSE IF(Category[i] = "playcount")
			{
            	IF(AtoI(Info[i]))
					Watched[ItemNumber] = ON;
			}
			// Note: using the JPG-version of Thumbnails!!!
			ELSE IF(Category[i] = "thumbnail") Thumb$[ItemNumber] = ThumbnailUri(Info[i],UseJpgExtension);
			ELSE IF(Category[i] = "fanart") Fanart$[ItemNumber] = ThumbnailUri(Info[i],UseJpgExtension);
		}


		ItemNumber = ItemNumber + 1;
    }

}
/*
    Return a JSON array with the given name.

	ArrayName: e.g. "\x22movies\x22", "\x22episodes\x22" etc.
*/
STRING_FUNCTION GetArrayFromResponse(STRING ArrayName, STRING Response$)
{
    STRING Array$[16384];

	INTEGER FirstSquareBracket; 
	INTEGER LastSquareBracket; 
    
    #IF_DEFINED DEBUG PRINT("Response$: %s", LEFT(Response$, 200)); #ENDIF

	FirstSquareBracket = FIND("[\x0A", Response$, Find(ArrayName, Response$)) + 3;
	LastSquareBracket = ReverseFind("],\x0A", Response$); 
	IF (LastSquareBracket = 0)
		LastSquareBracket = ReverseFind("]", Response$); 
	//#IF_DEFINED DEBUG PRINT("FirstSquareBracket: %d, LastSquareBracket: %d", FirstSquareBracket, LastSquareBracket); #ENDIF
	Array$ = MID(Response$, FirstSquareBracket, LastSquareBracket - FirstSquareBracket);
    //#IF_DEFINED DEBUG PRINT("MovieList$: %s", LEFT(MovieList$, 200)); #ENDIF

	RETURN (Array$);
}
   
/*
    Get the value of the "total" field in a List Response
*/
INTEGER_FUNCTION GetListTotalFromResponse(STRING Result$)
{
    STRING Total$[10];
    
	INTEGER IndexOfTotal;
	INTEGER IndexOfColon; 
	INTEGER IndexOfNextComma;
	INTEGER IndexOfOpeningArrayBracket;

	IndexOfTotal = Find("\x22total\x22", Result$); 
    
	IndexOfColon = FIND(":", Result$, IndexOfTotal);
	IndexOfNextComma = Find(",", Result$, IndexOfColon);
	IF (IndexOfNextComma=0)
		IndexOfNextComma = Find("}", Result$, IndexOfColon);

	Total$ = MID(Result$, IndexOfColon+1, IndexOfNextComma - IndexOfColon-1);
    #IF_DEFINED DEBUG PRINT("Total$: %s", Total$); #ENDIF

	RETURN (AtoI(Total$));
}

/*
  	Take the raw JSON result string and send it to the correct parsing function
*/
FUNCTION ParseJSONResult(INTEGER id, STRING Result$)
{
	IF (id = REQUESTID_MOVIELIBRARY_GETMOVIES)
	{
		List_Total = GetListTotalFromResponse(Result$);
        CALL UpdateOutputsFromBrowseList(
						GetArrayFromResponse("\x22movies\x22", Result$));
	}
	ELSE IF (id = REQUESTID_MOVIELIBRARY_GETTVSHOWS)
	{
		List_Total = GetListTotalFromResponse(Result$);
        CALL UpdateOutputsFromBrowseList(
						GetArrayFromResponse("\x22tvshows\x22", Result$));
	}
	else if (ID = REQUESTID_MOVIELIBRARY_GETTVSEASONS)
    {
        //#IF_DEFINED DEBUG PRINT("Result$: %s", Result$); #ENDIF
        List_Total = GetListTotalFromResponse(Result$);
        CALL UpdateOutputsFromBrowseList(
						GetArrayFromResponse("\x22seasons\x22", Result$));		
	}
	else if (ID = REQUESTID_MOVIELIBRARY_GETTVEPISODES)
    {
        //#IF_DEFINED DEBUG PRINT("Result$: %s", Result$); #ENDIF
        List_Total = GetListTotalFromResponse(Result$);
        CALL UpdateOutputsFromBrowseList(
						GetArrayFromResponse("\x22episodes\x22", Result$));		
	}	
	else if (ID = REQUESTID_AUDIOLIBRARY_GETARTISTS)
    {
        List_Total = GetListTotalFromResponse(Result$);
        CALL UpdateOutputsFromBrowseList(
						GetArrayFromResponse("\x22artists\x22", Result$));		
	}
	else if (ID = REQUESTID_AUDIOLIBRARY_GETALBUMS)
    {
        List_Total = GetListTotalFromResponse(Result$);
        CALL UpdateOutputsFromBrowseList(
						GetArrayFromResponse("\x22albums\x22", Result$));		
	}
	else if (ID = REQUESTID_AUDIOLIBRARY_GETSONGS)
    {
        List_Total = GetListTotalFromResponse(Result$);
        CALL UpdateOutputsFromBrowseList(
						GetArrayFromResponse("\x22songs\x22", Result$));		
	}
	else if (ID = REQUESTID_PLAYLIST_PLAYALLLIST)
    {
        CALL GetPlayAllPlaylistFromResponse(
						GetArrayFromResponse("\x22songs\x22", Result$),
						"\x22songid\x22");		
	}
	ELSE
	{
    	// Do nothing
	}

}

/*
  	Take the raw JSON error string and print it to Trace. 
	In future maybe I'll send it to the correct parsing function.
*/
FUNCTION ParseJSONError(INTEGER id, STRING Result$)
{
	Print("XBMC.usp: id:%d error:'%s'", id, LEFT(Result$,100));
}
      
/*
	Determine request id
*/
INTEGER_FUNCTION GetRequestID(STRING IN$)
{
    INTEGER Ind[1];		// Indices used in parsing input string
	STRING ID$[10];
	
	Ind[0] = FIND("id", IN$);
	Ind[0] = FIND(":", IN$, Ind[0]) + 1;
	Ind[1] = FIND(",\x0A", IN$, Ind[0]) - 1; 
	ID$ = MID(IN$, Ind[0], Ind[1] - Ind[0] + 1);
    ID$ = TRIM(ID$);

	RETURN (AtoI(ID$));
}
/*******************************************************************************************
  TCPIP Connection
*******************************************************************************************/ 

CHANGE Rx$
{
	INTEGER ID;  				// The request id. It is used to match the response
								// with the request that it is replying to.
	    
	STRING Response$[65534]; 	// The response from XBMC
	INTEGER Ind[2];				//Index variables used to parse the response  
                     
	//Semaphore
	WHILE (TCPBlocker) 
	{	
		Delay(10);
	}	
	TCPBlocker = 1;
    
	// Test for empty buffer (Can happen if buffer emptied by earlier event)
	IF (LEN(Rx$) = 0) 
	{
		TCPBlocker = 0;
		TERMINATEEVENT;
	}

	DO
	{
		Response$ = GATHER("<EOF>", Rx$, GATHER_TIMEOUT);		
	} 
	UNTIL (LEN(Response$));
    
	Response$ = LEFT(Response$, LEN(Response$) - 5); // remove <EOF> delimiter

	// Process the JSON payload, which is now in the Response$ variable
	IF (FIND ("result", Response$))
	{

		// Determine request id
        ID = GetRequestID(Response$);
              
		// 'result' string within XBMC Response
		Ind[0] = FIND ("{", Response$, Ind[0]);
		IF (Ind[0])
			Ind[1] = REVERSEFIND ("}\x0A", Response$);
		ELSE
		{
            Ind[0] = FIND (":", Response$, FIND ("result", Response$)) + 1;
			Ind[1] = REVERSEFIND ("\x0A}", Response$);
		}

		Response$ = MID(Response$, Ind[0], Ind[1] - Ind[0]);

		IF (ID)
			CALL ParseJSONResult(ID, Response$);  	
	}	

                
	// Reset the flag to zero
	TCPBlocker = 0;


}

/*******************************************************************************************
  Functions
  Note:  Functions must be physically placed before the location in
         the code that calls them.
*******************************************************************************************/

/*
	Send the JSON-RPC Post command
*/
Function SendJsonCommand(INTEGER id,  STRING Command , STRING Arguments)
{
	STRING Command$[16384];

	IF (SocketIsBusy)
	{
     	Delay(2);
	}

    IF (LEN(Arguments) = 0)
	{
		// \x22 is a double quote (")
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22}"
			,id ,Command);
	}
	ELSE
	{
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22,\x22params\x22:%s}"
			,id ,Command, Arguments);
	}	

	// Send out the command in chunks
	WHILE (LEN(Command$))
	{
		IF (LEN(Command$)>200)
		{
			// Send to serial out
			Tx$ = REMOVEBYLENGTH(200, Command$);
		}
		ELSE
		{
			// Append a delimiter ('\n') and send to serial out
			MAKESTRING(Tx$, "%s\n", Command$);
			Command$ = "";
		}
	}
	                        
}



/*
	Make the JSON command call that retrieves a browse list e.g. of Movies or Albums
	Depends on the global variable 'List_CurrentScreen'
*/
FUNCTION RepopulateCurrentList()
{
	INTEGER start;
	INTEGER end;
	STRING method[25];
	STRING Params$[512];

	start = List_PageNumber*StepAmount;
	end = (List_PageNumber+1)*(StepAmount);
	IF (List_Total > 0)
	{
		IF (end > List_Total) end = List_Total;
		MAKESTRING(List_Summary$, "%d to %d of %d", start+1, end, List_Total);
	}
	ELSE
		List_Summary$ = "";

	#IF_DEFINED DEBUG 
		PRINT("List_PageNumber: %d, StepAmount: %d", List_PageNumber , StepAmount);
		PRINT("Start: %d, End: %d", start , end);
	#ENDIF

	CALL Initialize_OutputArrays();
     
	SWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) :
		{
			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETMOVIES, 
				"VideoLibrary.GetMovies", VideoPlaylistParameters("",start,end,"sorttitle"));

		}
		CASE (TV_SHOW_LIST)		: 
		{ 
			method = "VideoLibrary.GetTvShows"; 
			Params$ = VideoPlaylistParameters("", start, end,"sorttitle");

			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETTVSHOWS, method, Params$);
		}
		CASE (TV_SEASON_LIST) 	: 
		{
			method = "VideoLibrary.GetSeasons";
			MAKESTRING (Params$, 
			"{\x22tvshowid\x22:%d,\x22fields\x22:[%s],%s,\x22start\x22:%d,\x22end\x22:%d}"
								,TvShowID
								,"\x22season\x22"
								,"\x22sort\x22:{\x22method\x22:\x22label\x22,\x22order\x22:\x22ascending\x22}"
								,start
								,end );
 
			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETTVSEASONS, method, Params$);
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
			method = "VideoLibrary.GetEpisodes"; 
			MAKESTRING (Params$, "\x22tvshowid\x22:%d,\x22season\x22:%d,"
							, TvShowID
							, TvShowSeasonID);
 			Params$ = VideoPlaylistParameters(Params$, start, end,"episode");

			CALL SendJsonCommand (REQUESTID_MOVIELIBRARY_GETTVEPISODES, method, Params$);
		}
		CASE (MUSIC_ALBUM_LIST)  : 
		{ 
			method = "AudioLibrary.GetAlbums"; 
			IF (ArtistID)
			{
				MAKESTRING(Params$, "\x22artistid\x22:%d,", ArtistID);
				Params$ = AudioPlaylistParameters(Params$, start, end,"label");
			}
			ELSE
				Params$ = AudioPlaylistParameters("", start, end,"label");

			CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_GETALBUMS, method, Params$);
		}
		CASE (MUSIC_ARTIST_LIST)  : 
		{ 
			method = "AudioLibrary.GetArtists"; 
 			Params$ = AudioPlaylistParameters("", start, end,"artist");

			CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_GETARTISTS, method, Params$);
		}
		CASE (MUSIC_SONG_LIST)  : 
		{ 
			method = "AudioLibrary.GetSongs"; 
			IF (AlbumID)
			{
				MAKESTRING(Params$, "\x22albumid\x22:%d,", AlbumID);
				Params$ = AudioPlaylistParameters(Params$, start, end,"track");
			}
			ELSE IF (ArtistID)
			{
				MAKESTRING(Params$, "\x22artistid\x22:%d,", ArtistID);
				Params$ = AudioPlaylistParameters(Params$, start, end,"title");
			}
			ELSE
				Params$ = AudioPlaylistParameters(Params$, start, end,"title");
				
            #IF_DEFINED DEBUG PRINT("Params$: %s", Params$); #ENDIF
			CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_GETSONGS, method, Params$);
		}
        DEFAULT: Print("XBMC.usp: (FUNCTION RepopulateCurrentList): Invalid ListID (%d)", List_CurrentScreen);
	}

	

}

/*
     Store in memory the id's of the 'Play all' playlist
*/
FUNCTION GetPlayAllPlaylist()
{
	STRING Params$[50];

	SWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) : { }
		CASE (TV_SHOW_LIST)		: { }
		CASE (TV_SEASON_LIST) 	: { }
		CASE (TV_EPISODE_LIST)  : { }
		CASE (MUSIC_SONG_LIST)  :
		{ 
			IF (AlbumID)
				MAKESTRING(Params$, 
							"{\x22albumid\x22:%d,\x22sort\x22:{\x22method\x22:\x22track\x22}}", 
							AlbumID);

			CALL SendJsonCommand (REQUESTID_PLAYLIST_PLAYALLLIST, 
									"AudioLibrary.GetSongs", Params$);
		}
		CASE (MUSIC_ARTIST_LIST)  : {}
		CASE (MUSIC_ALBUM_LIST)  : {}
    }
	
}

/*

*/
FUNCTION Play()
{
    STRING Parameter$[256];
    STRING PlaylistType$[13];
	STRING Command$[25];
	INTEGER I;
	Parameter$="";
	PlaylistType$="";

	SWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) :
		{
			MovieDetails = OFF;
			PlaylistType$ = "VideoPlaylist";
        	MAKESTRING(Parameter$, "{\x22movieid\x22:%d}", List_IDs[SelectedItem]);
		}
		CASE (TV_SHOW_LIST)		: {}
		CASE (TV_SEASON_LIST) 	: 
		{
			PlaylistType$ = "VideoPlaylist";
        	MAKESTRING(Parameter$, "{\x22seriesid\x22:%d,\x22seasonid\x22:%d}", 
										TvShowID, List_IDs[SelectedItem]);
		}
		CASE (TV_EPISODE_LIST)  : 
		{
			PlaylistType$ = "VideoPlaylist";
        	MAKESTRING(Parameter$, "{\x22episodeid\x22:%d}", 
										List_IDs[SelectedItem]);
		}
		CASE (MUSIC_ALBUM_LIST)  : {}
		CASE (MUSIC_ARTIST_LIST)  : {}
		CASE (MUSIC_SONG_LIST)  : 
		{
			SendJsonCommand(REQUESTID_PLAYLIST_CLEAR, 
									"AudioPlaylist.Clear","");
            Delay(JSON_DELAY);
            IF (AlbumID)
            {
				MAKESTRING(Command$,"%s.Add",PlaylistType$);
                WHILE (PlaylistIDs[I])	
				{
                	MAKESTRING(Parameter$, "{\x22songid\x22:%d}", 
										PlaylistIDs[I]);

                        
					SendJsonCommand(REQUESTID_PLAYLIST_ADD, "AudioPlaylist.Add", Parameter$);

					I = I + 1;
				}

			    Delay(JSON_DELAY);
				MAKESTRING(Command$,"%s.Play",PlaylistType$);
				SendJsonCommand(REQUESTID_PLAYLIST_PLAY, "AudioPlaylist.Play", "");
			    Delay(JSON_DELAY);
				PULSE(10, CheckCurrentlyPlaying);

				RETURN;
			}
			ELSE IF (ArtistID)
            {

			}
			ELSE
			{
				// Play One Song
				PlaylistType$ = "AudioPlaylist";
        		MAKESTRING(Parameter$, "{\x22songid\x22:%d}", 
										List_IDs[SelectedItem]);
			}
			
		}
	}

	MAKESTRING(Command$,"%s.Clear",PlaylistType$);
	SendJsonCommand(REQUESTID_PLAYLIST_CLEAR, Command$,"");
    Delay(JSON_DELAY);
	MAKESTRING(Command$,"%s.Add",PlaylistType$);
	SendJsonCommand(REQUESTID_PLAYLIST_ADD, Command$, Parameter$);
    Delay(JSON_DELAY);
	MAKESTRING(Command$,"%s.Play",PlaylistType$);
	SendJsonCommand(REQUESTID_PLAYLIST_PLAY, Command$, "");
    Delay(300); // Wait 3 seconds before requesting metadata
	PULSE(10, CheckCurrentlyPlaying);
}


 
/********************************************************************************
*
* EVENT handlers
*
********************************************************************************/
/*
  	Play the selected item
*/
CHANGE PlayItem
{
	//#IF_DEFINED DEBUG Print("%s", "In Play()."); #ENDIF
	Play();

	MovieDetails = OFF;
    TvShowDetails = OFF;
}

/*
  	The given item has been selected from a list
*/
CHANGE SelectedItem
{

	SWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST) 	: 
		{
			MovieDetails = ON;
		}
		CASE (TV_SHOW_LIST) 	: 
		{
	        List_CurrentScreen = TV_SEASON_LIST;
			OldShowListPage = List_PageNumber;
			TvShowID = List_IDs[SelectedItem];
			List_PageNumber = 0;
			List_Total = 0;
			RepopulateCurrentList();
			IsTvShowList = OFF;
		}
		CASE (TV_SEASON_LIST) 	: 
		{
	        List_CurrentScreen = TV_EPISODE_LIST;
			OldSeasonListPage = List_PageNumber;
			TvShowSeasonID = List_IDs[SelectedItem];
			List_PageNumber = 0;
			List_Total = 0;
			RepopulateCurrentList();		
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
    	    TvShowDetails = ON;	
	    	MovieDetails = OFF;
		}
		CASE (MUSIC_ALBUM_LIST)  : 
		{ 
	        List_CurrentScreen = MUSIC_SONG_LIST;
			OldAlbumListPage = List_PageNumber;
			AlbumID = List_IDs[SelectedItem];
			List_PageNumber = 0;
			List_Total = 0;
			IsAlbumList = OFF;
			IsSongList = ON;

			GetPlayAllPlaylist();
			Delay(JSON_DELAY);
			RepopulateCurrentList();

		}
		CASE (MUSIC_ARTIST_LIST)  : 
		{ 
	        List_CurrentScreen = MUSIC_ALBUM_LIST;
			OldArtistListPage = List_PageNumber;
			ArtistID = List_IDs[SelectedItem];
			List_PageNumber = 0;
			List_Total = 0;
			IsSongList = OFF;
			IsArtistList = OFF;
			IsAlbumList = ON;
			RepopulateCurrentList();

		}
		CASE (MUSIC_SONG_LIST)  : 
		{ 
			Play();
		}

        DEFAULT: 
		{
			// do Nothing			
		}
	}
}

CHANGE PlotItem
{
	//#IF_DEFINED DEBUG Print("PlotItem changed. Now value = %d", PlotItem); #ENDIF
	SendPlotAsIndirectText(List_Plot$[PlotItem]);
}

PUSH List_Back
{
	#IF_DEFINED DEBUG Print("List_CurrentScreen = %d", List_CurrentScreen); #ENDIF
	SWITCH (List_CurrentScreen)
	{
		CASE (MOVIE_TITLE_LIST)					: 
		{
			MovieDetails = OFF;
			TERMINATEEVENT;	// don't need to reload current list values;
		}
		CASE (TV_SEASON_LIST) 	: 
		{
			List_PageNumber = OldShowListPage;
			List_CurrentScreen = TV_SHOW_LIST;
		}
		CASE (TV_EPISODE_LIST)  : 
		{ 
			List_PageNumber = OldSeasonListPage;
			List_CurrentScreen = TV_SEASON_LIST;
		}
        DEFAULT: 
		{
			List_PageNumber = 0;			
		}
	}

	CALL RepopulateCurrentList();

}

PUSH List_TopPage
{
	List_PageNumber = 0;

	CALL RepopulateCurrentList();
}

PUSH List_BottomPage
{
	IF (List_Total)
        List_PageNumber = (List_Total - (List_Total MOD StepAmount)) / StepAmount;
	ELSE
		List_PageNumber = 0;
   
	#IF_DEFINED DEBUG Print("List_Total: %d, List_PageNumber: %d", List_Total, List_PageNumber); #ENDIF

	CALL RepopulateCurrentList();
}


PUSH List_PageMinus
{ 	
	IF (List_PageNumber) 
	{
		List_PageNumber = List_PageNumber - 1;
	}

	CALL RepopulateCurrentList();
}

PUSH List_PagePlus
{
	List_PageNumber = List_PageNumber + 1;                                  

	IF (List_Total)
	{
		IF (List_PageNumber*StepAmount > List_Total)
		{
         	List_PageNumber = (List_Total - (List_Total MOD StepAmount))/StepAmount;
		}
	}

	CALL RepopulateCurrentList();
}

PUSH List_Movies
{

	List_CurrentScreen = MOVIE_TITLE_LIST;
    IsMovieList = ON;
	IsTvShowList = OFF;
	IsAlbumList = OFF;
	IsArtistList = OFF;
	IsSongList = OFF;
    TvShowDetails = OFF;	
   	MovieDetails = OFF;

	List_PageNumber = 0;
	List_Total = 0;

	CALL RepopulateCurrentList();
}

PUSH List_TvShows
{
	List_CurrentScreen = TV_SHOW_LIST;
    IsMovieList = OFF;
	IsTvShowList = ON;
	IsAlbumList = OFF;
	IsArtistList = OFF;
	IsSongList = OFF;
    TvShowDetails = OFF;	
   	MovieDetails = OFF;

	List_PageNumber = 0;
	List_Total = 0;

	CALL RepopulateCurrentList();
}

PUSH List_Albums
{
	List_CurrentScreen = MUSIC_ALBUM_LIST;
    IsMovieList = OFF;
	IsTvShowList = OFF;
	IsAlbumList = ON;
	IsArtistList = OFF;
	IsSongList = OFF;

	List_PageNumber = 0;
	List_Total = 0;
	ArtistID = 0;

	CALL RepopulateCurrentList();
}

PUSH List_Artists
{
	List_CurrentScreen = MUSIC_ARTIST_LIST;
    IsMovieList = OFF;
	IsTvShowList = OFF;
	IsAlbumList = OFF;
	IsArtistList = ON;
	IsSongList = OFF;

	List_PageNumber = 0;
	List_Total = 0;
	AlbumID = 0;

	CALL RepopulateCurrentList();
}

PUSH List_Songs
{
	List_CurrentScreen = MUSIC_SONG_LIST;
    IsMovieList = OFF;
	IsTvShowList = OFF;
	IsAlbumList = OFF;
	IsArtistList = OFF;
	IsSongList = ON;
    TvShowDetails = OFF;	
   	MovieDetails = OFF;

	List_PageNumber = 0;
	List_Total = 0;
	AlbumID = 0;
	ArtistID = 0;

	CALL RepopulateCurrentList();
}

PUSH List_Exit_Details_Page
{
	TvShowDetails = OFF;	
   	MovieDetails = OFF;
}
  