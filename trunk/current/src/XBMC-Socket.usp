/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name:
System Number:
Programmer: Neil Carthy (arduino@scpgwiki.com)
Comments:        

	This module contains the raw socket code necessary to send and receive
	JSON messages using the XBMC TCP Server. This server is usually on port
    9090 and it is separate from (and faster than) the HTTP webserver (port 8080).
	
	To use this module:
	- Set IP address of XBMC and port number (usually 9090) in SIMPL windows
	- Send the JSON command with "\n" at the end to the input buffer (IN$)
		e.g. {"id":1,"jsonrpc":"2.0","method":"Player.GetActivePlayers"}\n
	- You will receive XBMC's reply on OUT$, the end of the response is
		indicated by the tag <EOF>.                                     
    
	***** License *****

	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*******************************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*******************************************************************************************/
#SYMBOL_NAME "XBMC-Socket"
#CATEGORY "41" // Remote System Interface
#HINT "Interact with XBMC JSON api using raw TCP."  


/////////////////////Compiler Directives
#PRINT_TO_TRACE
#ENABLE_DYNAMIC
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#OUTPUT_SHIFT 3			// Shift the outputs down 3 lines on the SIMPL window

#DEFINE_CONSTANT GATHER_TIMEOUT 1000 // 10 seconds
   
/*******************************************************************************************
  Include Libraries
  (Uncomment and include additional libraries as needed)
*******************************************************************************************/
//#USER_LIBRARY "base64"
//#USER_LIBRARY "Common_Functions"

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
*******************************************************************************************/

DIGITAL_INPUT _SKIP_,_SKIP_, _SKIP_;
DIGITAL_INPUT Connect;					//  When HIGH connect to the XBMC tcp socket.
BUFFER_INPUT IN$[16384];				// JSON command IN
DIGITAL_OUTPUT Connected, _SKIP_;		// HIGH when connected.
DIGITAL_OUTPUT Busy, _SKIP_;			// HIGH when transmitting JSON command to server
STRING_OUTPUT OUT$;						// JSON reply OUT

///////////////////////////// Parameters
STRING_PARAMETER XBMC_IPAddr$[16];   //the ip of the XBMC server.
STRING_PARAMETER XBMC_Port$[5];		 //the port that the XBMC server lives on

/*******************************************************************************************
  Parameter Properties
*******************************************************************************************/
#BEGIN_PARAMETER_PROPERTIES XBMC_IPAddr$ 
   propDefaultValue = "";  
   propShortDescription = "The IP Address of the XBMC HTTP server.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES XBMC_Port$
   propDefaultValue = "";   
   propShortDescription = "The port that XBMC accepts raw TCP JSON commands on (usu 9090).";
#END_PARAMETER_PROPERTIES
   
/*******************************************************************************************
  SOCKETS
*******************************************************************************************/
TCP_CLIENT XBMC[16384];			// Socket for connecting to running XBMC

/*******************************************************************************************
  Global Variables
  (Uncomment and declare global variables as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: myString = "";
*******************************************************************************************/
SIGNED_INTEGER ConnectionStatus;	// Status of XBMC socket, used to determine if 
									// the Connect event needs to reconnect or do nothing.

STRING Command$[2000];				// Bufferred command, not transmitted until receive final "\n"
STRING Received$[65534];			// Bufferred response received from XBMC. Not transmitted until
									// the number of { & } are equal.	

INTEGER RxBlocker;					// Semaphore for incomplete JSON packets. A packet is not complete
									// until the number of { & } are equal.
INTEGER TxBlocker;					// Semaphore for command (IN$)

INTEGER NumStartBrackets;			// Number of opening curly brackets '{'	
INTEGER NumEndBrackets;				// Number of closing curly brackets '}'
		
/*******************************************************************************************
  Functions
  Note:  Functions must be physically placed before the location in
         the code that calls them.
*******************************************************************************************/
/*
  	Close the connection and wait for status to show 'disconnected'
*/        
FUNCTION DisconnectFromXbmc()
{
	INTEGER count;
	count = 0;

	IF ( ConnectionStatus <> 5 )
	{
		// close the connection
	    ConnectionStatus = SocketDisconnectClient (XBMC);
	
		// wait for the connection to be established
		while( ( ConnectionStatus <> 5 ) && ( count < 10 ) )
		{
			delay( 20 );
			count = count + 1;
		}
    } 


}

/*
  	Establish a connection and wait for status to show 'connected'
*/
FUNCTION ConnectToXbmc()
{
	INTEGER count;
	count = 0;
    
	IF ( ConnectionStatus <> 2 )
	{

		// open the connection			// '1' = always attempt to reconnect.
	    ConnectionStatus = SocketConnectClient (XBMC, XBMC_IPAddr$, AtoI(XBMC_Port$), 1);
	
		// wait for the connection to be established
		while( ( ConnectionStatus <> 2 ) && ( count < 10 ) )
		{
			delay( 20 );
			count = count + 1;
		}
    } 
}

/*
  	Examine a given string for the presence of curly brackets {,}
	Increment module-level counters if brackets found.
	When number of opening and closing brackets are equal return 1, otherwise 0.
	Counters are module-level because full JSON response is bufferred and we
	are only examining it piece by piece.
*/ 
INTEGER_FUNCTION CountBrackets(STRING Json$)
{
	INTEGER Index;

    // find number of { brackets
	Index = FIND("{", Json$);
	WHILE (Index)
	{
     	NumStartBrackets = NumStartBrackets + 1;
		Index = FIND("{", Json$, Index+1);
	}

    // find number of } brackets
	Index = FIND("}", Json$);
	WHILE (Index > 0)
	{
     	NumEndBrackets = NumEndBrackets + 1;
		Index = FIND("}", Json$, Index+1);
	}

	IF ( NumStartBrackets > 0 && NumEndBrackets > 0 
					&& NumStartBrackets = NumEndBrackets)
	{
	    NumStartBrackets = 0;
		NumEndBrackets = 0;
		RETURN (1);
	}
	ELSE
		RETURN (0);
}

/*******************************************************************************************
  Event Handlers
*******************************************************************************************/
PUSH Connect
{
	// connect to XBMC
	ConnectToXbmc();

}
RELEASE Connect
{
 	// disconnect from XBMC
	DisconnectFromXbmc();
}

CHANGE IN$
{
	//Semaphore
	WHILE (TxBlocker) 
	{	
		Delay(10);
	}	
	TxBlocker = 1;
	Busy = ON;
    
	// Test for empty buffer (Can happen if buffer emptied by earlier event)
	IF (LEN(IN$) = 0) 
	{
		TxBlocker = 0;
		TERMINATEEVENT;
	}

	Command$ = GATHER("\n", IN$, GATHER_TIMEOUT);
    SocketSend(XBMC, Command$);

	// Reset the flags to zero
	TxBlocker = 0;
	Busy = OFF;
}
   
/*******************************************************************************************
  Socket Logic
*******************************************************************************************/
SOCKETCONNECT XBMC
{
    SIGNED_INTEGER LocalStatus;
    STRING RequestedAddress[256];

    LocalStatus = SocketGetAddressAsRequested(XBMC, RequestedAddress);
    if (LocalStatus < 0)
	{
        Print("Error connecting to remote ip address. Status: %d\n", LocalStatus);
		Connected = OFF;
	}
    ELSE
	{
    	Print("OnConnect: Connect call to %s successful\n", RequestedAddress);
		Connected = ON;
	}
}
 
SOCKETDISCONNECT XBMC
{
	PRINT("XBMC Socket disconnected.");
	Connected = OFF;
}
      
SOCKETRECEIVE XBMC
{
	STRING Response$[65534];   
                     
	//Semaphore
	WHILE (RxBlocker) 
	{	
		Delay(10);
	}	
	RxBlocker = 1;
    
	// Test for empty buffer (Can happen if buffer emptied by earlier event)
	IF (LEN(XBMC.SocketRxBuf) = 0) 
	{
		RxBlocker = 0;
		TERMINATEEVENT;
	}
    
	// Gather from the buffer to the first closing curly bracket
	// Then check if JSON response is complete by counting opening and closing brackets
	// Loop until complete message received.
	DO
	{
		Response$ = GATHER("}", XBMC.SocketRxBuf, GATHER_TIMEOUT);
        Received$ = Received$ + Response$;
	} 
	UNTIL (CountBrackets(Response$));
    
	// Test for residual characters in the buffer that should be discarded
	IF (LEN(XBMC.SocketRxBuf) < 10)
		IF (FIND("{", XBMC.SocketRxBuf) = 0)
			ClearBuffer(XBMC.SocketRxBuf);

	// Send out the reply in chunks
	WHILE (LEN(Received$))
	{
		IF (LEN(Received$)>200)
		{
			// Send to serial out
			OUT$ = REMOVEBYLENGTH(200, Received$);
		}
		ELSE
		{
			// Append a delimiter ('<EOF>') and send to serial out
			MAKESTRING(OUT$, "%s<EOF>", Received$);
			Received$ = "";
		}
	}
                
	// Reset the flag to zero
	RxBlocker = 0;
	TxBlocker = 0;

}
