/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name: XBMC
System Number: 1.0
Programmer: Neil Carthy (arduino@scpgwiki.com)
Comments:                                             
    
	***** License *****

	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#SYMBOL_NAME "XBMC"
#CATEGORY "41" // Remote System Interface
#HINT "Control XBMC using JSON api. Communicate metadata of currently playing media."  


/////////////////////Compiler Directives
#PRINT_TO_TRACE
#ENABLE_DYNAMIC
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#OUTPUT_SHIFT 8			// Shift the outputs down 8 lines on the SIMPL window

#USER_LIBRARY "Common_Functions"

/*****    DEFINE NEW CONSTANTS    *******/
//#DEFINE_CONSTANT DEBUG 1              // Uncomment this to see debug messages
#DEFINE_CONSTANT JSON_DELAY 	30		// Delay between JSON calls in 1/100th of second
#DEFINE_CONSTANT GATHER_TIMEOUT 1000    // 10 seconds 
#DEFINE_CONSTANT BUFFER_SIZE 40000      // large!

//Useful characters that we'll need in parsing metadata
#DEFINE_CONSTANT CR 0x0D		 	// Carriage return
#DEFINE_CONSTANT LF 0x0A		 	// Linefeed
#DEFINE_CONSTANT TAB 0x09		 	// Tab
#DEFINE_CONSTANT SPACE 0x20	   		// Space
#DEFINE_CONSTANT DBLQUOTE 0x22	   	// "
#DEFINE_CONSTANT BACKSLASH 0x5C	   	// \
                  
/* Types of playing media, output via Currently_Playing_Type*/
#DEFINE_CONSTANT TYPE_NONE							 0
#DEFINE_CONSTANT TYPE_MOVIE							 1
#DEFINE_CONSTANT TYPE_AUDIO							 2
#DEFINE_CONSTANT TYPE_SERIES					     3
#DEFINE_CONSTANT TYPE_PICTURES						 4
#DEFINE_CONSTANT TYPE_OTHERVIDEO					 5

/* REequest IDs for different JSON-RPC commands */
#DEFINE_CONSTANT REQUESTID_GETACTIVEPLAYERS				1
#DEFINE_CONSTANT REQUESTID_GETINFOLABELS				2
#DEFINE_CONSTANT REQUESTID_AUDIOPLAYLIST_GETITEMS		3
#DEFINE_CONSTANT REQUESTID_VIDEOPLAYLIST_GETITEMS		4
#DEFINE_CONSTANT REQUESTID_GETTIME_SECONDS				5
#DEFINE_CONSTANT REQUESTID_GETTIME_PERCENTAGE			6
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETMOVIES		7 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETMOVIEDETAILS	8 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVSHOWS		9 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVSEASONS	10 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVEPISODES	11 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETEPISODEDETS	12 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETARTISTS		13 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETALBUMS		14 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETSONGS		15 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_PLAYLIST_CLEAR				16 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_PLAYLIST_ADD					17 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_PLAYLIST_PLAY				18 // Request Ids 7-20 are handled by XBMC-Browse
#DEFINE_CONSTANT REQUESTID_PLAYLIST_PLAYALLLIST			19 // Request Ids 7-20 are handled by XBMC-Browse
                                                          
#DEFINE_CONSTANT REQUESTID_SKIPNEXT						22
#DEFINE_CONSTANT REQUESTID_SKIPPREV						23
#DEFINE_CONSTANT REQUESTID_SMALLSKIPFORWARD				24
#DEFINE_CONSTANT REQUESTID_SMALLSKIPBACKWARD			25
#DEFINE_CONSTANT REQUESTID_LARGESKIPFORWARD				26
#DEFINE_CONSTANT REQUESTID_LARGESKIPBACKWARD			27
#DEFINE_CONSTANT REQUESTID_VIDEOLIBRARY_SCAN			28
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_SCAN			29


/* ActivePlayer IDs */
#DEFINE_CONSTANT ACTIVEPLAYER_NONE						0
#DEFINE_CONSTANT ACTIVEPLAYER_AUDIO						1
#DEFINE_CONSTANT ACTIVEPLAYER_SLIDESHOW					2
#DEFINE_CONSTANT ACTIVEPLAYER_VIDEO						4


/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
DIGITAL_OUTPUT PlayFb,					// HIGH when something is playing
			   StopFb,					// HIGH when playback is stopped
		       PauseFb;					// HIGH when playback is paused
                 	
STRING_OUTPUT 	_SKIP_,
				CurrentFilename$,				// The file name of the currently playing track
				CurrentTitle$,_SKIP_,		    // The name of the current track
				CurrentCoverArt$,				// The uri of the coverart for the current track
				CurrentCoverArtJPEG$,_SKIP_,	// The uri of a JPEG of the coverart for the current track
                CurrentTime$,					// The time that the movie/track ahs been playing
				CurrentDuration$,				// total length of movie/track
				CurrentPercentage$,_SKIP_,		// the percent that the track has progressed
 				CurrentGenre$,					// Music/Movie genre
				CurrentStudio$,					// Movie studio
				CurrentDirector$,				// The movie director's name.
                CurrentWriter$,					// Movie writer
				CurrentTagLine$,				// Movie tag line
				CurrentRating$,					// imdb rating
				CurrentYear$,_SKIP_,			// The year the song/movie was released				
				CurrentShowTitle$,				// TV Show title
				CurrentSeason$,					// TV Show season
				CurrentEpisode$,				// TV Show episode
				CurrentFirstAired$,				// TV Show first aired date
				CurrentPlot$,_SKIP_,		    // DVD synopsis
				CurrentTrackNumber$,			// The track number				
				CurrentArtist$,			   		// The artist of the current track
				CurrentAlbum$,			        // The album of the current track
				CurrentAudioBitRate$,_SKIP_,	// audio bitrate
				AudioCodec$,					// audio codec
				VideoCodec$,_SKIP_,				// video codec
				NextTitle$,						// Metadata about next item on playlist
				NextArtist$,					// Metadata about next item on playlist
				NextGenre$,						// Metadata about next item on playlist
				NextAlbum$,						// Metadata about next item on playlist
				NextTrackNumber$,				// Metadata about next item on playlist
				PlayStatus$,					// 'Stopped', 'Playing', 'Paused'
				PlayingSpeed$,                  // Speed of current audio/video playback (1x, 2x, 4x etc.)  
				_SKIP_,							
				IPAddress$,						// This is passed to XBMC-ES module (EventServer module)
				_SKIP_,
				Tx$,							// Json Command to XBMC (delimited by "\n"			
				_SKIP_;


ANALOG_OUTPUT   Position_Seconds, 
				Duration_Seconds, 
				Progress_Percentage,	// The percentage that the track has progressed				
				Currently_Playing_Type; // 1 = movie, 2 = audio, 3 = tv, 4= picture, 5 = other video
				
DIGITAL_INPUT _SKIP_, _SKIP_,_SKIP_, _SKIP_,_SKIP_, _SKIP_;

/* INPUTs for the remote commands */
DIGITAL_INPUT _SKIP_, PlayNext, PlayPrev;
DIGITAL_INPUT UpdateMovies, UpdateMusic;
DIGITAL_INPUT JumpFwd_Sm, JumpBack_Sm, JumpFwd_Lg, JumpBack_Lg;

DIGITAL_INPUT IsPlayingOnExternalPlayer, _SKIP_; // HIGH if movie is playing on mpc-hc, use to prevent GetCurrentTime updates
              
/* INPUTs to trigger 'Currently Playing' and 'Time' metadata Update */
DIGITAL_INPUT CheckCurrentlyPlaying, Get_Time, ClearCurrentlyPlaying, _SKIP_;

DIGITAL_INPUT IsConnected; // HIGH when a xbmc socket is connected;
DIGITAL_INPUT SocketIsBusy, _SKIP_; // HIGH when a JSON command is being transmitted;

ANALOG_INPUT Seek_Percentage, Seek_Time; 	// Seek to this %age, time.

STRING_INPUT  _SKIP_;	
BUFFER_INPUT Rx$[BUFFER_SIZE];				// The reply from XBMC

///////////////////////////// Parameters
STRING_PARAMETER XBMC_IPAddr$[16];   //the ip of the XBMC server.
STRING_PARAMETER XBMC_Port$[5];		 //the port that the XBMC server lives on
INTEGER_PARAMETER UseJpgExtension;	 // Use '.jpg' as thumbnail extension instead of '.tbn'
STRING_PARAMETER LOGIN[30];			 // Username for http server (used to download thumbnails) 
STRING_PARAMETER PASSWORD[30];		 // Password for http server (used to download thumbnails)

/*******************************************************************************************
  Parameter Properties
  (Uncomment and declare parameter properties as needed)
*******************************************************************************************/
#BEGIN_PARAMETER_PROPERTIES XBMC_IPAddr$ 
    propDefaultValue = "";  
    propShortDescription = "The IP Address of the XBMC HTTP server.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES XBMC_Port$
   propDefaultValue = "";   
   propShortDescription = "The port that the XBMC HTTP server is listening on. (NOT the tcp server)";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES UseJpgExtension
	propValidUnits = unitDecimal;
    propDefaultUnit = unitDecimal;
    propDefaultValue = 0d;
    propShortDescription = "Use jpg as thumbnail extension instead of tbn";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES LOGIN
   propDefaultValue = "xbmc";   
   propShortDescription = "Login for HTTP Basic Authentication. Set 0d if no login. Max 30 chars.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES PASSWORD
   propDefaultValue = "xbmc";   
   propShortDescription = "Password for HTTP Basic Authentication. Set 0d if no password. Max 30 chars.";
#END_PARAMETER_PROPERTIES

/////////////////////////// Global Variables
STRING CoverArtInternal$[512];					   // Uri of coverart thumb. Stored internally so that
												   // a comparison can be made. This is b'cos the TPS-6X
												   // is easily overloaded by dynamic graphic calls.
INTEGER PlaylistPosition;						   // The (zero-based) number of the track in the current playlist
INTEGER ActivePlayer;							   // 1 = audio, 2 = slideshow, 4 = video
INTEGER List_PageNumber;						   // The (zero-based) current page number of the list;
INTEGER List_Total;								   // The total number of items in the current browse list
STRING List_Filename$[10][1024];				   // The filenames of all the items in the current list
INTEGER List_IDs[10];							   // The ids of the items in the browse list
INTEGER SeasonNumber[10];						   // The number of the TV show seasons listed
INTEGER OldShowListPage,OldSeasonListPage,OldArtistListPage,OldAlbumListPage;
INTEGER TvShowID, TvShowSeasonID, TvShowEpisodeID, AlbumID, ArtistID;
INTEGER PlaylistIDs[100];						   // The songids/movieids etc. of the current playlist
STRING List_Plot$[10][1024];						   // An internal store of the Plot (which is a long string)
												   // done this way to circumvent limitation on length of
												   // indirect text to VT-Pro-e programs
INTEGER TCPBlocker;					// Semaphore for incomplete JSON packets. A packet is not complete
									// until we receive the '\n' delimiter.
SIGNED_INTEGER PlaySpeed;			// Speed of current audio/video playback (1x, 2x, 4x etc.)
INTEGER IsTvShow;					// =1 when a Tv Show is playing on the xbmc, 0 otherwise
INTEGER IsPlaying;					// =1 when media is playing on the xbmc, 0 otherwise

STRING ResultName$[20][40];
STRING ResultValue$[20][2000];
INTEGER NameValueCount;

/*
  	Set the video outputs to appropiate state depending on current status
*/
Function SetVideoStatus(INTEGER Status)
{

	if (Status = ON)
	{
		ActivePlayer = ACTIVEPLAYER_VIDEO;
		PlayFb = ON;
		IsPlaying = 1;
		#IF_DEFINED DEBUG PRINT("ActivePlayer: %d (video)", ActivePlayer); #ENDIF
		IF (ISTvShow)
			Currently_Playing_Type = TYPE_SERIES;
		ELSE
			Currently_Playing_Type = TYPE_MOVIE;
	}
	else
	{
		ActivePlayer = ActivePlayer & 251; // switch off the 3rd bit
	}
}

/*
  	Set the audio outputs to appropiate state depending on current status
*/
Function SetAudioStatus(INTEGER Status)
{
	if (Status = ON)
	{
		PlayFb = ON;
		IsPlaying = 1;
		ActivePlayer = ACTIVEPLAYER_AUDIO;
		#IF_DEFINED DEBUG PRINT("ActivePlayer: %d (audio)", ActivePlayer); #ENDIF
		Currently_Playing_Type = TYPE_AUDIO; 
	}
	else
	{
		ActivePlayer = ActivePlayer & 254; // switch off the 1st bit
	}
}
  
/*
  	Set the picture outputs to appropiate state depending on current status
*/
Function SetSlideShowStatus(INTEGER Status)
{
	if (Status = ON)
	{
		ActivePlayer 	= 2;
		PlayFb 			= ON;
		IsPlaying 		= 1;
		#IF_DEFINED DEBUG PRINT("ActivePlayer: %d (slideshow)", ActivePlayer); #ENDIF
		Currently_Playing_Type = TYPE_PICTURES; //Pictures
	}
	else
	{
		ActivePlayer = ActivePlayer & 253; // switch off the 2nd bit
	}
}
 
/*
	DELAY until socket is clear
*/
Function WaitforSocketToClear()
{
	WHILE (TCPBlocker)
	{
     	delay(1);
	}
}

/*******************************************************************************************
  XBMC Response logic
*******************************************************************************************/
/*
  	Return a string containing the xbmc parameter list for Video Playlists
*/
STRING_FUNCTION VideoPlaylistParameters(STRING AdditionalParameters, INTEGER start, INTEGER end
											,STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{%s\x22fields\x22:[%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22},\x22start\x22:%d,\x22end\x22:%d}"
								, AdditionalParameters
								,"\x22title\x22"
								,"\x22originaltitle\x22"
								,"\x22director\x22"
								,"\x22tagline\x22"
								,"\x22genre\x22"
								,"\x22showtitle\x22"
								,"\x22runtime\x22"
								,"\x22year\x22"
								,"\x22rating\x22"
								,"\x22writer\x22"
								,"\x22studio\x22"
								//,"\x22plotoutline\x22"
								,"\x22plot\x22"
								,"\x22season\x22"
								,"\x22episode\x22"
								,"\x22firstaired\x22"
								,"\x22studio\x22"
								,"\x22mpaa\x22"
								,"\x22playcount\x22"
								,SortMethod
								,start
								,end 
					);
 
	#IF_DEFINED DEBUG PRINT( "VideoPlaylistParameters:%s", LEFT(Params$,200)  ); #ENDIF

	RETURN (Params$);
}
/*
  	Return a string containing the xbmc parameter list for Audio Playlists
*/
STRING_FUNCTION AudioPlaylistParameters(STRING AdditionalParameters, INTEGER start, INTEGER end
											,STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{%s\x22fields\x22:[%s,%s,%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22},\x22start\x22:%d,\x22end\x22:%d}"
								, AdditionalParameters
								,"\x22title\x22"
								,"\x22artist\x22"
								,"\x22album\x22"
								,"\x22genre\x22"
								,"\x22year\x22"
								,"\x22rating\x22"
								,"\x22duration\x22"
								,"\x22tracknumber\x22"
								,SortMethod
								,start
								,end 
					);
	#IF_DEFINED DEBUG PRINT( "AudioPlaylistParameters:%s", LEFT(Params$,200)  ); #ENDIF

	RETURN (Params$);
}

/*
    Take the uri given by XBMC and add http://, ip_address, port etc.
	When UseJPG = 1, Use the extension '.jpg' instead of '.tbn'.
*/
STRING_FUNCTION ThumbnailUri(STRING uri$, INTEGER UseJPG)
{
	STRING tmpCoverPath[512];
	IF(LOGIN <> "0d" && PASSWORD <> "0d"){
		tmpCoverPath = "http://" + LOGIN + ":" + PASSWORD + "@" + XBMC_IPAddr$ + ":"+ XBMC_Port$ + "/";
	}	
	ELSE{
		tmpCoverPath = "http://" + XBMC_IPAddr$ + ":"+ XBMC_Port$ + "/";
	}
	IF (UseJPG)
		tmpCoverPath = tmpCoverPath + "vfs:" + LEFT(uri$, LEN(uri$) - 4) + ".jpg";
	ELSE
		tmpCoverPath = tmpCoverPath + "vfs:" + uri$;
    RETURN (tmpCoverPath);
}

/*
    Send the plot string (usu very long) to a STRING_OUTPUT
	Done this way to overcome length restriction on Indirect Text joins
*/
FUNCTION SendPlotAsIndirectText(STRING longstring$)
{
	STRING chunk[100];	
	STRING Original$[5000];

	Original$ = longstring$;

	// Must reset the output string.
    CurrentPlot$ = "";

	while (len(longstring$))
	{
		if (len(longstring$)>100)
		{
			chunk = removebylength(100, longstring$);
		}
		else
		{
			chunk = longstring$;
			longstring$ = "";
		}
		CurrentPlot$ = "\xFE\x02" + chunk;
	}	

	longstring$ = Original$;
}

/*
	Set the outputs to a default empty state
*/
FUNCTION Initialize_Outputs()
{
	CurrentFilename$ = "";				// The file name of the currently playing track
	CurrentTitle$ = "";		    		// The name of the current track
	CurrentCoverArt$ = "";				// The uri of the coverart for the current track
	CurrentCoverArtJPEG$ = "";			// The uri of a JPEG of the coverart for the current track
    CurrentTime$ = "";					// The time that the movie/track ahs been playing
	CurrentDuration$ = "";				// total length of movie/track
	CurrentPercentage$ = "";			// the percent that the track has progressed
 	CurrentGenre$ = "";					// Music/Movie genre
	CurrentStudio$ = "";				// Movie studio
	CurrentDirector$ = "";				// The movie director's name.
    CurrentWriter$ = "";				// Movie writer
	CurrentTagLine$ = "";				// Movie tag line
	CurrentRating$ = "";				// imdb rating
	CurrentYear$ = "";					// The year the song/movie was released				
	CurrentShowTitle$ = "";				// TV Show title
	CurrentSeason$ = "";				// TV Show season
	CurrentEpisode$ = "";				// TV Show episode
	CurrentFirstAired$ = "";			// TV Show first aired date
	CurrentPlot$ = "";					// shortened version of plot
	CurrentTrackNumber$ = "";			// The track number				
	CurrentArtist$ = "";			    // The artist of the current track
	CurrentAlbum$ = "";			        // The album of the current track
	CurrentAudioBitRate$ = "";			// audio bitrate
	AudioCodec$ = "";					// audio codec
	VideoCodec$ = "";					// video codec
	NextTitle$ = "";					// Metadata about next item on playlist
	NextArtist$ = "";					//
	NextGenre$ = "";					//
	NextAlbum$ = "";					//
	NextTrackNumber$ = "";				//

	Progress_Percentage = 0;
	Position_Seconds = 0; 
	Duration_Seconds = 0;			
	Currently_Playing_Type = TYPE_NONE;

	PlaylistPosition = 0;
	ActivePlayer = ACTIVEPLAYER_NONE;
	ISTvShow = 0;

	PauseFb = OFF;
	StopFb = ON;
	PlayFb = OFF;

	CoverArtInternal$ = "";
}

/*
	Update IsVideo, IsAudio and IsSlideshow digital outputs from the GetActivePlayers response

	The original JSON would have been of the form (ignoring whitespace):
	 				{"audio":false,"picture":false,"video":true}
	
	The ParseObject method has transferred the names and values to 
	the ResultName$ and ResultValue$ arrays.

*/
FUNCTION GetActivePlayersFromResponse()
{
	INTEGER i;

	FOR (i = 1 TO 3)
	{
		IF (ResultName$[i] = "audio")
			IF (ResultValue$[i] = "true")
				SetAudioStatus(ON);
			ELSE
				SetAudioStatus(OFF);

		ELSE IF (ResultName$[i] = "video")	
			IF (ResultValue$[i] = "true")
				SetVideoStatus(ON);
			ELSE
				SetVideoStatus(OFF);
		ELSE IF (ResultName$[i] = "picture")	
			IF (ResultValue$[i] = "true")
				SetSlideShowStatus(ON);
			ELSE
				SetSlideShowStatus(OFF);
		ELSE
			PRINT ("XBMC.usp (GetActivePlayersFromResponse): Unknown ResultName (%s)", LEFT(ResultName$[i], 20));
				    	
	}
	
	IF (!ActivePlayer) 
	{
		PauseFb = OFF;
		StopFb = ON;
		PlayFb = OFF;
		IsPlaying = 0;
		Currently_Playing_Type 	= TYPE_NONE;
	}
}


/*
    Update metadata of currently playing (and next playing) using response that returned a playlist

	Item$:			The JSON description of the Item
	NextInPlaylist:	When =1 then Item$ contains details of the next track in the playlist
					When =0 then Item$ contains details of the current track in the playlist		
*/
FUNCTION GetMetadataFromList(INTEGER NextInPlaylist)
{
    INTEGER i;
	STRING CoverartTmp[512];//The coverart uri. Must be treated as a special case due to TPS-6X limitations
    
	#IF_DEFINED DEBUG PRINT ("NextInPlaylist %d, NameValueCount %d ", NextInPlaylist, NameValueCount); #ENDIF

	// Assign to OUTPUTs
	IF(!NextInPlaylist)
	{
		FOR (i = 1 to NameValueCount)
		{
	     	IF (ResultName$[i] = "file") CurrentFilename$ = RIGHT(ResultValue$[i],255); //SIMPL strings can only be 255 chars long
			ELSE IF(ResultName$[i] = "title") CurrentTitle$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "tracknumber") CurrentTrackNumber$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "artist") CurrentArtist$ = ResultValue$[i];
	 		ELSE IF(ResultName$[i] = "album") CurrentAlbum$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "genre") CurrentGenre$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "director") CurrentDirector$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "year") CurrentYear$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "musicplayer.bitrate") CurrentAudioBitRate$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "musicplayer.codec") AudioCodec$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "videoplayer.videocodec") VideoCodec$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "rating") CurrentRating$ = Round(ResultValue$[i],2);		
	        ELSE IF(ResultName$[i] = "studio") CurrentStudio$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "writer") CurrentWriter$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "showtitle") CurrentShowTitle$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "season") CurrentSeason$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "episode") CurrentEpisode$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "firstaired") CurrentFirstAired$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "tagline") CurrentTagLine$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "plot") SendPlotAsIndirectText(ResultValue$[i]);
			ELSE IF(ResultName$[i] = "thumbnail") 
			{
				CurrentCoverArt$ = ThumbnailUri(ResultValue$[i],UseJpgExtension);
				CoverartTmp = ThumbnailUri(ResultValue$[i],UseJpgExtension);
			}
			ELSE IF(ResultName$[i] = "time") 
			{
				Position_Seconds = AtoI(ResultValue$[i]);
				CurrentTime$ = ConvertToTime(Position_Seconds);
			}
			ELSE IF(ResultName$[i] = "total") 
			{
				Duration_Seconds = AtoI(ResultValue$[i]);
				CurrentDuration$ = ConvertToTime(Duration_Seconds);					
			}
			ELSE IF(ResultName$[i] = "Playlist.position")
			{
				PlaylistPosition = AtoI(ResultValue$[i]);
	            IF (PlaylistPosition)
					PlaylistPosition = PlaylistPosition -1; // make it zero-based    	
				ELSE
					CALL Initialize_Outputs();
	            #IF_DEFINED DEBUG PRINT("PlaylistPosition: %d", PlaylistPosition); #ENDIF
			}
		}
	    
		// Only update the String_output if the coverart has actually changed
		// This is b'cos the TPS-6X is easily overloaded by dynamic graphic calls
		IF (LEN(CoverartTmp) && CoverartTmp <> CoverArtInternal$) 
		{
			#IF_DEFINED DEBUG PRINT("Coverart Updated."); #ENDIF
			CoverArtInternal$ = CoverartTmp;
			CurrentCoverArtJPEG$ = CoverartTmp;
		}    
	}
	ELSE
	{
		FOR (i = 1 to NameValueCount)
		{
	     	IF(ResultName$[i] = "title") NextTitle$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "tracknumber") NextTrackNumber$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "artist") NextArtist$ = ResultValue$[i];
	 		ELSE IF(ResultName$[i] = "album") NextAlbum$ = ResultValue$[i];
			ELSE IF(ResultName$[i] = "genre") NextGenre$ = ResultValue$[i];
		}
	}
}

/*
    Parse a JSON result object that does not contain an array.

	The JSON result object is required to be of the form (ignoring whitespace):
	 				{"name1":"value1","name2":"value2","name3":.. etc.   ..}
	
	This method will then transfer the names and values to the ResultName$ 
	and ResultValue$ arrays.

*/

FUNCTION ParseObject(STRING Result$)
{
	INTEGER loop;
	INTEGER character;				// current character from the buffer
	INTEGER prevCharacter;			// previous character from the buffer
	INTEGER inputLength;			// length of Result$
	INTEGER SkipCharacter;			// when =1 drop character, otherwise process it
	INTEGER DoubleQuotesCount;		// number of quotes ("). Used to determine if inside a string
	INTEGER InItemName;				// when =1 we are currently parsing the name of a name/value pair
	INTEGER outputPosition;			// position in output string

	// initialize
	InItemName = 1;
	NameValueCount = 1;
	outputPosition = 1;
	SetArray(ResultName$,"");		// These are module-level arrays
	SetArray(ResultValue$,"");		//

	inputLength = len(Result$);
	
	for(loop = 1 to inputLength) //step through every character of Buffer input
	{
		SkipCharacter = 0;
		character = byte(Result$, loop); //extract it
		switch(character) //examine it
		{
			case ('{'):
			{
				IF (IsEven(DoubleQuotesCount))
					SkipCharacter = 1;
			}
			case ('}'):
			{
				IF (IsEven(DoubleQuotesCount))
					SkipCharacter = 1;						
			}

            case (DBLQUOTE): // " (double quotes)
			{
				IF (prevCharacter != BACKSLASH) // Avoid case where double quote is escaped (\")
				{
            		DoubleQuotesCount = DoubleQuotesCount + 1;
					SkipCharacter = 1;
				}
			}
			case (','):
			{
				// Ignore the comma that seperates individual array items
				IF (IsEven(DoubleQuotesCount))
				{
					InItemName = 1;
					SkipCharacter = 1;
					outputPosition = 1;
					NameValueCount = NameValueCount+1;
				}
					
			}
            case (':'):
			{
				IF (IsEven(DoubleQuotesCount))
				{
					InItemName = 0;
					SkipCharacter = 1;
					outputPosition = 1;			
				}
			}
			case (BACKSLASH):
			{
            	IF (IsEven(DoubleQuotesCount))
				{
					IF (prevCharacter != BACKSLASH)	// Avoid case where backslash is escaped (\\)		
						SkipCharacter = 1;
				}

			}
		}

		IF (!SkipCharacter)
		{
			//append the character
			IF (InItemName)
				setString(chr(character), outputPosition, ResultName$[NameValueCount]);				
			ELSE
				setString(chr(character), outputPosition, ResultValue$[NameValueCount]);								

			// increment counter
            outputPosition = outputPosition + 1;
		}         
        
		// store previous character
		prevCharacter = character;   
		 
	}
    
	#IF_DEFINED DEBUG 
		FOR (loop = 1 to NameValueCount)
		{
	    	IF (LEN(ResultName$[loop]))
				PRINT ("XBMC.usp:ParseObject() %s: %s", ResultName$[loop], LEFT(ResultValue$[loop], 100));
			ELSE
				Break;
		}
	#ENDIF
}

/*
    Update metadata using JSON result object that contains an array of
	one or at most 2 items: "[{...}]" or "[{...},{...}]"
*/
FUNCTION GetMetadataFromResponse(STRING Response$)
{
	INTEGER ItemsArrayBookends[2];	//Start and end of the items list
	INTEGER ListItemBookends[2];	//Start and end of an item in the items list
	STRING Item$[16384];			//A single item

	// Assumption:
	// The first item in the array contains details of the track that's currently playing
	// The second item in the array contains details of the track that's next in the playlist

	// Mark out the start and end of (i) the "items" array and (ii) the first item in the array
	ItemsArrayBookends[0] = Find("[", Response$);    
	//ItemsArrayBookends[1] = Find("]", Response$, ItemsArrayBookends[0]);
	ListItemBookends[0] = Find("{", Response$, ItemsArrayBookends[0]);    
	ListItemBookends[1] = Find("}", Response$, ListItemBookends[0]);    

	Item$ = MID(Response$, ListItemBookends[0], ListItemBookends[1] - ListItemBookends[0]);  
	ParseObject(Item$);
	CALL GetMetadataFromList(0);
                

	// Mark out the start and end of the second item in the array
	ListItemBookends[0] = Find("{", Response$, ListItemBookends[1]); 
	IF ( ListItemBookends[0] = 0) 
		RETURN;
   
	ListItemBookends[1] = Find("}", Response$, ListItemBookends[0]);
	IF ( ListItemBookends[1] = 0) ListItemBookends[1] = LEN(Response$);
	Item$ = MID(Response$, ListItemBookends[0], ListItemBookends[1] - ListItemBookends[0]);
    ParseObject(Item$);
	CALL GetMetadataFromList(1);

}


/*
	Analyse and respond to the content of an Announcement message

	Typical form of announcement message:
	{}
*/
FUNCTION ParseAnnouncementMessage(STRING Announcement$)
{
	INTEGER Ind[2];			//Index variables used to parse the response 
    STRING Message$[100];
	STRING TempSpeed$[3];
	
	Ind[0] = FIND("message", Announcement$);
	Ind[1] = FIND(":", Announcement$, Ind[0]) + 1;
	Ind[2] = FIND(",", Announcement$, Ind[1]);

	Message$ = MID(Announcement$, Ind[1], Ind[2] - Ind[1]);

	#IF_DEFINED DEBUG 	
		PRINT("Message: %s\n", Message$);
    #ENDIF

	If(Find("Action", Message$) || Find("PlayBackSeek",Message$) 
						|| Find("MediaChanged",Message$)
						|| Find("QueueNextItem", Message$) 
						|| Find("NewSong", Message$)
						|| Find("NewPlayCount", Message$)
						|| Find("ApplicationStop", Message$)
						|| Find("ApplicationStart", Message$)
						|| Find("Sleep", Message$))
	{
		// Do Nothing
	}
	Else If(Find("SpeedChanged", Message$))
	{                
		Ind[0] = FIND("speed", Announcement$);
		Ind[1] = FIND(":", Announcement$, Ind[0]) + 1;
		Ind[2] = FIND("}", Announcement$, Ind[1]) - 1;
		TempSpeed$ = TRIM(mid(Announcement$, Ind[1], Ind[2] - Ind[1])); 

		if (Find("-",TempSpeed$)) 
			PlaySpeed 	= -(atoi(TempSpeed$));
		else
			PlaySpeed 	= atoi(TempSpeed$);
		
		MakeString(PlayingSpeed$,"%dx",PlaySpeed); 
	}	
	Else If(Find("PlaybackStarted", Message$))
	{
		PauseFb		= 0; 
		StopFb		= 0; 
		PlayFb		= 1; 
		PlaySpeed	= 1; 
		Makestring(PlayingSpeed$, "%dx", PlaySpeed);
		PlayStatus$ = "Playing";
	}
	Else If(Find("PlaybackPaused", Message$)) 
	{
		StopFb			= 0; 
		PlayFb			= 0; 
		PauseFb			= 1; 
		PlayingSpeed$ 	= ""; 
		PlayStatus$ = "Paused";
	}
	Else If(Find("PlaybackEnded", Message$) || Find("PlaybackStopped", Message$))
	{
		PlayFb					= 0; 
		PauseFb					= 0;
		StopFb					= 1; 
		PlayingSpeed$ 			= ""; 
		PlayStatus$ = "Stopped";
		CALL Initialize_Outputs();
	}
	Else If(Find("PlaybackResumed", Message$))
	{
		PauseFb					= 0; 
		StopFb					= 0; 
		PlayFb					= 1; 
		PlaySpeed				= 1; 
		PlayStatus$ = "Playing";
		Makestring(PlayingSpeed$, "%dx", PlaySpeed);
	}
	Else If(Find("StartUp", Message$) > 0)
	{
		CALL Initialize_Outputs();
	}
	Else
		PRINT("XBMC.usp: Unknown announcement: %s\n", LEFT(Announcement$,200));
}

/*
  	Take the raw JSON result string and send it to the correct parsing function
*/
FUNCTION ParseJSONResult(INTEGER id, STRING Result$)
{
	IF (id = REQUESTID_GETACTIVEPLAYERS)
	{
		CALL ParseObject(Result$);
		CALL GetActivePlayersFromResponse();
	}
	ELSE IF (id = REQUESTID_GETINFOLABELS)
	{
		CALL ParseObject(Result$);
		CALL GetMetadataFromList(0);
	}
	ELSE IF (id = REQUESTID_AUDIOPLAYLIST_GETITEMS)
	{
		CALL GetMetadataFromResponse(Result$);	
	}
	ELSE IF (id = REQUESTID_VIDEOPLAYLIST_GETITEMS)
	{
		IF ( FIND("showtitle",Result$) )
			IsTVShow = 1; 
		ELSE 
			IsTVShow = 0;
		CALL GetMetadataFromResponse(Result$);
	}
	ELSE IF (id = REQUESTID_GETTIME_SECONDS)
	{
		CALL ParseObject(Result$);

		//Update the duration and time of the current track
		CALL GetMetadataFromList(0);
	}
	ELSE IF (id = REQUESTID_GETTIME_PERCENTAGE)
	{
		// XBMC does not return JSON in this case
		CurrentPercentage$ = Round(Result$,0)+"%";
		Progress_Percentage = AtoI(Round(Result$,0));
	}
	ELSE IF (ID >= REQUESTID_MOVIELIBRARY_GETMOVIES
				&& ID <= REQUESTID_PLAYLIST_PLAYALLLIST)
    {
        // Do Nothing.
		// Handled by XBMC-Browse		
	}
	ELSE IF (FIND("OK", Result$) || (FIND("success", Result$) && FIND("true", Result$)))
	{
		// Got an 'OK' result
    	// Do nothing
	}
	ELSE
	{
		GenerateUserError("%s: Unhandled Result string. id=%d, Result=%s", 
				GetSymbolInstanceName(), id, LEFT(Result$,100));
	}

}

/*
  	Take the raw JSON error string and print it to Trace. 
	In future maybe I'll send it to the correct parsing function.
*/
FUNCTION ParseJSONError(INTEGER id, STRING Result$)
{
	Print("XBMC.usp: id:%d error:'%s'", id, LEFT(Result$,100));
}
      
/*
	Determine request id
*/
INTEGER_FUNCTION GetRequestID(STRING IN$)
{
    INTEGER Ind[1];		// Indices used in parsing input string
	STRING ID$[10];
	
	Ind[0] = FIND("id\x22:", IN$)+ 4;
	Ind[1] = FIND(",", IN$, Ind[0]) - 1; 
	ID$ = MID(IN$, Ind[0], Ind[1] - Ind[0] + 1);

	RETURN (AtoI(ID$));
}

/*
	Parse the JSON reply from Xbmc to either:
		i) select the 'result' object from the XbmcResponse
		ii) select the 'error' object from the XbmcResponse
		iii) select the 'params' object from the XbmcResponse, if the message is an Announcement
*/
FUNCTION ProcessResponse(STRING Response$)
{
	INTEGER ID;  				// The request id. It is used to match the response
								// with the request that it is replying to.
	INTEGER Ind[2];				//Index variables used to parse the response  

	#IF_DEFINED DEBUG  Print("Payload Received (%d bytes): %s", LEN(Response$), LEFT(Response$,200)); #ENDIF

	// Process the JSON payload, which is now in the Response$ variable
	Ind[0] = FIND ("result", Response$);
	IF (Ind[0])
	{

		// Determine request id
        ID = GetRequestID(Response$);
              
		// 'result' string within XBMC Response
		Ind[0] = FIND ("{", Response$, Ind[0]);
		IF (Ind[0])
			Ind[1] = REVERSEFIND ("}}", Response$);
		ELSE
		{
			// To capture the case of GetPercentage() which doesn't return a result object...
			// instead it returns a number as the result e.g. "{id:7,jsonrpc:2.0,result:5.6578436456}"
            Ind[0] = FIND (":", Response$, FIND ("result", Response$)) + 1;
			Ind[1] = REVERSEFIND ("}", Response$);
		}
		IF (Ind[1]=0)
			Ind[1] = LEN(Response$);

		Response$ = MID(Response$, Ind[0], Ind[1] - Ind[0] + 1);

		IF (ID)
			CALL ParseJSONResult(ID, Response$);  	
	}
	// Announcement?
	ELSE IF (FIND ("Announcement", Response$))
	{
       	Ind[0] = FIND (":", Response$, FIND ("params", Response$)) + 1;
		Ind[1] = REVERSEFIND ("}", Response$);
		IF (Ind[1]=0)
			Ind[1] = LEN(Response$);
		
		Response$ = MID(Response$, Ind[0], Ind[1] - Ind[0] + 1);

        CALL ParseAnnouncementMessage(Response$);
	}
	// JSON error?
	ELSE IF (FIND ("error", Response$))
	{
		// Determine request id
        ID = GetRequestID(Response$);
              
		// 'error' string within XBMC Response
        Ind[0] = FIND (":", Response$, FIND ("error", Response$)) + 1;
		Ind[1] = REVERSEFIND ("}}", Response$);
		IF (Ind[1]=0)
			Ind[1] = LEN(Response$);

		Response$ = MID(Response$, Ind[0], Ind[1] - Ind[0] + 1);
                 
		IF (ID)
			CALL ParseJSONError(ID, Response$);
		ELSE 
			Print("XBMC.usp: id:%d error:%s", ID, LEFT(Response$,200));
	}
	ELSE
	{
		Print("XBMC.usp (ProcessResponse): Unrecognised Payload: %s", LEFT(Response$,190));
	}	
    
	TCPBlocker = 0;
}

/*
	Send the JSON-RPC command
*/
Function SendJsonCommand(INTEGER id,  STRING Command , STRING Arguments)
{
	STRING Command$[16384];

	IF (IsConnected = OFF)
		RETURN;
	
	WHILE (SocketIsBusy || TCPBlocker)
	{		
		IF (id = REQUESTID_GETTIME_SECONDS ||
				id = REQUESTID_GETTIME_PERCENTAGE)
			RETURN;

     	Delay(2);
	}
	TCPBlocker = 1;
	Wait(200) // 2-second timeout
	{
    	TCPBlocker = 0; 	
	}                      

    IF (LEN(Arguments) = 0)
	{
		// \x22 is a double quote (")
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22}"
			,id ,Command);
	}
	ELSE
	{
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22,\x22params\x22:%s}"
			,id ,Command, Arguments);
	}	

	// Send out the command in chunks
	WHILE (LEN(Command$))
	{
		IF (LEN(Command$)>200)
		{
			// Send to serial out
			Tx$ = REMOVEBYLENGTH(200, Command$);
		}
		ELSE
		{
			// Append a delimiter ('\n') and send to serial out
			MAKESTRING(Tx$, "%s\n", Command$);
			Command$ = "";
		}
	}
 
}


/* 
	Retrieve Current Player
*/
FUNCTION GetActivePlayers()
{
	CALL SendJsonCommand (REQUESTID_GETACTIVEPLAYERS, "Player.GetActivePlayers", "");
}
/*
	Retrieve current playlist position
*/
FUNCTION GetCurrentPlaylistPositionAndInfoLabels()
{
	STRING Params$[1024];

	MAKESTRING(Params$, "[%s,%s,%s,%s]"
								,"\x22Playlist.position\x22" // \x22 is a double quote (")
								,"\x22musicplayer.bitrate\x22"
								,"\x22musicplayer.codec\x22"
								,"\x22videoplayer.videocodec\x22"
			);
						  					      
 	CALL SendJsonCommand (REQUESTID_GETINFOLABELS, "System.GetInfoLabels", Params$);

	// Note:
	// Usable info labels defined in http://wiki.xbmc.org/?title=InfoLabels
	// and implemented in TranslateSingleString in GUIInfoManager.cpp (xbmc src code)
}

/*
	Retrieve current time & percentage progress through track
*/
FUNCTION GetCurrentTime()
{
	// If playing on an external player then don't use this function
	IF(IsPlayingOnExternalPlayer) RETURN;	

	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) //audio
	{
		CALL SendJsonCommand (REQUESTID_GETTIME_SECONDS, 
										"AudioPlayer.GetTime", "");
		WaitforSocketToClear();
		CALL SendJsonCommand (REQUESTID_GETTIME_PERCENTAGE, 
									"AudioPlayer.GetPercentage","");
	}
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
	{
		CALL SendJsonCommand (REQUESTID_GETTIME_SECONDS, 
											"VideoPlayer.GetTime", "");
		WaitforSocketToClear();		
		CALL SendJsonCommand (REQUESTID_GETTIME_PERCENTAGE, 
									"VideoPlayer.GetPercentage", "");
	}
	ELSE
	{
		CurrentTime$ = "";
		CurrentDuration$ = "";
		Progress_Percentage = 0;
		Position_Seconds = 0;
		Duration_Seconds = 0;
	}
}


/*
	Retrieve current time & percentage progress through track
*/
FUNCTION UpdateMetadata()
{
	CALL GetActivePlayers();	   
	WaitforSocketToClear();
    
	IF (IsPlaying)
		CALL GetCurrentPlaylistPositionAndInfoLabels();
	ELSE
		CALL Initialize_Outputs();

	WaitforSocketToClear();
  	
	// only return the current item and one more
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO)
	{
    	CALL SendJsonCommand (REQUESTID_AUDIOPLAYLIST_GETITEMS, 
									"AudioPlaylist.GetItems", 
									AudioPlaylistParameters("", 
								PlaylistPosition, PlaylistPosition+2, "track"));
	}
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO)
	{
		CALL SendJsonCommand (REQUESTID_VIDEOPLAYLIST_GETITEMS, 
			"VideoPlaylist.GetItems", VideoPlaylistParameters("",
								PlaylistPosition,PlaylistPosition+1,"sorttitle"));		
	}

}

 
/********************************************************************************
*
* EVENT handlers
*
********************************************************************************/

push PlayNext
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO)
		CALL SendJsonCommand (REQUESTID_SKIPNEXT, "AudioPlaylist.SkipNext","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO)
		CALL SendJsonCommand (REQUESTID_SKIPNEXT, "VideoPlaylist.SkipNext", "");
}
push PlayPrev
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_SKIPPREV, "AudioPlaylist.SkipPrev","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_SKIPPREV, "VideoPlaylist.SkipPrev", "");
} 
push JumpFwd_Sm
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPFORWARD, 
									"AudioPlayer.SmallSkipForward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPFORWARD, 
									"VideoPlayer.SmallSkipForward", "");
}
push JumpFwd_Lg
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPFORWARD, 
									"AudioPlayer.BigSkipForward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPFORWARD, 
									"VideoPlayer.BigSkipForward", "");
}
push JumpBack_Sm
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPBACKWARD, 
									"AudioPlayer.SmallSkipBackward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPBACKWARD, 
									"VideoPlayer.SmallSkipBackward", "");
}
push JumpBack_Lg
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPBACKWARD, 
									"AudioPlayer.BigSkipBackward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPBACKWARD, 
									"VideoPlayer.BigSkipBackward", "");
}    
push CheckCurrentlyPlaying
{
	CALL UpdateMetadata();
}
PUSH ClearCurrentlyPlaying
{
 	CALL Initialize_Outputs();
}
PUSH Get_Time
{
	IF (IsPlaying)
		CALL GetCurrentTime();
} 
push UpdateMovies
{
	CALL SendJsonCommand (REQUESTID_VIDEOLIBRARY_SCAN, 
								"VideoLibrary.ScanForContent", "");
}  
push UpdateMusic
{
    CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_SCAN, 
								"AudioLibrary.ScanForContent", "");

} 


CHANGE Seek_Percentage
{
	STRING Time$[10];
	MAKESTRING(Time$, "%d", Seek_Percentage);
    
	IF (IsPlaying)
	{
		IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
			CALL SendJsonCommand (30, "AudioPlayer.SeekPercentage",Time$);
		ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
			CALL SendJsonCommand (30, "VideoPlayer.SeekPercentage", Time$);
	}

}

CHANGE Seek_Time
{
	STRING Time$[10];
	MAKESTRING(Time$, "%d", Seek_Time);
    
	IF (IsPlaying)
	{
		IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
			CALL SendJsonCommand (31, "AudioPlayer.SeekTime",Time$);
		ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
			CALL SendJsonCommand (31, "VideoPlayer.SeekTime", Time$);
	}
}

  
///////////// Initialization script
Function Main()
{     
	    
	STRING Xbmc$[BUFFER_SIZE]; 	// The response from XBMC

                       
	// This line must be before WaitForInitializationComplete()
	// This IP address is passed to XBMC-ES via this output
	IPAddress$ = XBMC_IPAddr$;

	List_PageNumber = 0;

	WaitForInitializationComplete();
     
    // Eternal loop, waiting for Data from Xbmc 
	WHILE(1)
	{
  		Xbmc$ = Gather("\n", RX$);
		CALL ProcessResponse(Xbmc$);		
	} 

}
       