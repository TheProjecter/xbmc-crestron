/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name: XBMC
System Number: 1.0
Programmer: Neil Carthy (arduino@scpgwiki.com)
Comments:                                             
    
	***** License *****

	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#SYMBOL_NAME "XBMC"
#CATEGORY "46" "HTTP Operations" // Custom Category
#HINT "Control XBMC over HTTP"  


/////////////////////Compiler Directives
#PRINT_TO_TRACE
#ENABLE_DYNAMIC
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#OUTPUT_SHIFT 8			// Shift the outputs down 6 lines on the SIMPL window

#USER_LIBRARY "Common_Functions"

/*****    DEFINE NEW CONSTANTS    *******/
//#DEFINE_CONSTANT DEBUG 1              // Uncomment this to see debug messages
#DEFINE_CONSTANT JSON_DELAY 	30		// Delay between JSON calls in 1/100th of second
#DEFINE_CONSTANT GATHER_TIMEOUT 1000    // 10 seconds 
                   
/* Types of playing media, output via Currently_Playing_Type*/
#DEFINE_CONSTANT TYPE_NONE							 0
#DEFINE_CONSTANT TYPE_MOVIE							 1
#DEFINE_CONSTANT TYPE_AUDIO							 2
#DEFINE_CONSTANT TYPE_SERIES					     3
#DEFINE_CONSTANT TYPE_PICTURES						 4
#DEFINE_CONSTANT TYPE_OTHERVIDEO					 5

/* REequest IDs for different JSON-RPC commands */
#DEFINE_CONSTANT REQUESTID_GETACTIVEPLAYERS				1
#DEFINE_CONSTANT REQUESTID_GETINFOLABELS				2
#DEFINE_CONSTANT REQUESTID_AUDIOPLAYLIST_GETITEMS		3
#DEFINE_CONSTANT REQUESTID_VIDEOPLAYLIST_GETITEMS		4
#DEFINE_CONSTANT REQUESTID_GETTIME_SECONDS				5
#DEFINE_CONSTANT REQUESTID_GETTIME_PERCENTAGE			6
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETMOVIES		7
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVSHOWS		8
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVSEASONS	9
#DEFINE_CONSTANT REQUESTID_MOVIELIBRARY_GETTVEPISODES	10
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETARTISTS		11
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETALBUMS		12
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_GETSONGS		13
#DEFINE_CONSTANT REQUESTID_PLAYLIST_CLEAR				14
#DEFINE_CONSTANT REQUESTID_PLAYLIST_ADD					15
#DEFINE_CONSTANT REQUESTID_PLAYLIST_PLAY				16
#DEFINE_CONSTANT REQUESTID_PLAYLIST_PLAYALLLIST			17
                                                          
#DEFINE_CONSTANT REQUESTID_SKIPNEXT						22
#DEFINE_CONSTANT REQUESTID_SKIPPREV						23
#DEFINE_CONSTANT REQUESTID_SMALLSKIPFORWARD				24
#DEFINE_CONSTANT REQUESTID_SMALLSKIPBACKWARD			25
#DEFINE_CONSTANT REQUESTID_LARGESKIPFORWARD				26
#DEFINE_CONSTANT REQUESTID_LARGESKIPBACKWARD			27
#DEFINE_CONSTANT REQUESTID_VIDEOLIBRARY_SCAN			28
#DEFINE_CONSTANT REQUESTID_AUDIOLIBRARY_SCAN			29


/* ActivePlayer IDs */
#DEFINE_CONSTANT ACTIVEPLAYER_NONE						0
#DEFINE_CONSTANT ACTIVEPLAYER_AUDIO						1
#DEFINE_CONSTANT ACTIVEPLAYER_SLIDESHOW					2
#DEFINE_CONSTANT ACTIVEPLAYER_VIDEO						4

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
DIGITAL_OUTPUT PlayFb,					// HIGH when something is playing
			   StopFb,					// HIGH when playback is stopped
		       PauseFb;					// HIGH when playback is paused
                 	
STRING_OUTPUT 	_SKIP_,
				CurrentFilename$,				// The file name of the currently playing track
				CurrentTitle$,_SKIP_,		    // The name of the current track
				CurrentCoverArt$,				// The uri of the coverart for the current track
				CurrentCoverArtJPEG$,_SKIP_,	// The uri of a JPEG of the coverart for the current track
                CurrentTime$,					// The time that the movie/track ahs been playing
				CurrentDuration$,				// total length of movie/track
				CurrentPercentage$,_SKIP_,		// the percent that the track has progressed
 				CurrentGenre$,					// Music/Movie genre
				CurrentStudio$,					// Movie studio
				CurrentDirector$,				// The movie director's name.
                CurrentWriter$,					// Movie writer
				CurrentTagLine$,				// Movie tag line
				CurrentRating$,					// imdb rating
				CurrentYear$,_SKIP_,			// The year the song/movie was released				
				CurrentShowTitle$,				// TV Show title
				CurrentSeason$,					// TV Show season
				CurrentEpisode$,				// TV Show episode
				CurrentFirstAired$,				// TV Show first aired date
				CurrentPlot$,_SKIP_,		    // DVD synopsis
				CurrentTrackNumber$,			// The track number				
				CurrentArtist$,			   		// The artist of the current track
				CurrentAlbum$,			        // The album of the current track
				CurrentAudioBitRate$,_SKIP_,	// audio bitrate
				AudioCodec$,					// audio codec
				VideoCodec$,_SKIP_,				// video codec
				NextTitle$,						// Metadata about next item on playlist
				NextArtist$,					// Metadata about next item on playlist
				NextGenre$,						// Metadata about next item on playlist
				NextAlbum$,						// Metadata about next item on playlist
				NextTrackNumber$,				// Metadata about next item on playlist
				PlayStatus$,					// 'Stopped', 'Playing', 'Paused'
				PlayingSpeed$,                  // Speed of current audio/video playback (1x, 2x, 4x etc.)  
				_SKIP_,							
				IPAddress$,						// This is passed to XBMC-ES module (EventServer module)
				_SKIP_,
				Tx$,							// Json Command to XBMC (delimited by "\n"			
				_SKIP_;


ANALOG_OUTPUT   Position_Seconds, 
				Duration_Seconds, 
				Progress_Percentage,	// The percentage that the track has progressed				
				Currently_Playing_Type; // 1 = movie, 2 = audio, 3 = tv, 4= picture, 5 = other video
				
DIGITAL_INPUT _SKIP_, _SKIP_,_SKIP_, _SKIP_,_SKIP_, _SKIP_;

/* INPUTs for the remote commands */
DIGITAL_INPUT _SKIP_, PlayNext, PlayPrev;
DIGITAL_INPUT UpdateMovies, UpdateMusic;
DIGITAL_INPUT JumpFwd_Sm, JumpBack_Sm, JumpFwd_Lg, JumpBack_Lg;

DIGITAL_INPUT IsPlayingOnExternalPlayer, _SKIP_; // HIGH if movie is playing on mpc-hc, use to prevent GetCurrentTime updates
              
/* INPUTs to trigger 'Currently Playing' and 'Time' metadata Update */
DIGITAL_INPUT CheckCurrentlyPlaying, Get_Time, ClearCurrentlyPlaying, _SKIP_, _SKIP_;

ANALOG_INPUT Seek_Percentage, Seek_Time; 	// Seek to this %age, time.

STRING_INPUT  _SKIP_;	
BUFFER_INPUT Rx$[65534];					// The reply from XBMC

///////////////////////////// Parameters
STRING_PARAMETER XBMC_IPAddr$[16];   //the ip of the XBMC server.
STRING_PARAMETER XBMC_Port$[5];		 //the port that the XBMC server lives on
//INTEGER_PARAMETER StepAmount;		 // Only return this many results from database at a time
INTEGER_PARAMETER UseJpgExtension;	 // Use '.jpg' as thumbnail extension instead of '.tbn'
STRING_PARAMETER LOGIN[30];			 // Username for http server (used to download thumbnails) 
STRING_PARAMETER PASSWORD[30];		 // Password for http server (used to download thumbnails)

/*******************************************************************************************
  Parameter Properties
  (Uncomment and declare parameter properties as needed)
*******************************************************************************************/
#BEGIN_PARAMETER_PROPERTIES XBMC_IPAddr$ 
    propDefaultValue = "";  
    propShortDescription = "The IP Address of the XBMC HTTP server.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES XBMC_Port$
   propDefaultValue = "";   
   propShortDescription = "The port that the XBMC HTTP server is listening on. (NOT the tcp server)";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES UseJpgExtension
	propValidUnits = unitDecimal;
    propDefaultUnit = unitDecimal;
    propDefaultValue = 0d;
    propShortDescription = "Use jpg as thumbnail extension instead of tbn";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES LOGIN
   propDefaultValue = "xbmc";   
   propShortDescription = "Login for HTTP Basic Authentication. Set 0d if no login. Max 30 chars.";
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES PASSWORD
   propDefaultValue = "xbmc";   
   propShortDescription = "Password for HTTP Basic Authentication. Set 0d if no password. Max 30 chars.";
#END_PARAMETER_PROPERTIES

/////////////////////////// Global Variables
STRING CoverArtInternal$[512];					   // Uri of coverart thumb. Stored internally so that
												   // a comparison can be made. This is b'cos the TPS-6X
												   // is easily overloaded by dynamic graphic calls.
INTEGER PlaylistPosition;						   // The (zero-based) number of the track in the current playlist
INTEGER ActivePlayer;							   // 1 = audio, 2 = slideshow, 4 = video
INTEGER List_PageNumber;						   // The (zero-based) current page number of the list;
INTEGER List_Total;								   // The total number of items in the current browse list
STRING List_Filename$[10][1024];				   // The filenames of all the items in the current list
INTEGER List_IDs[10];							   // The ids of the items in the browse list
INTEGER SeasonNumber[10];						   // The number of the TV show seasons listed
INTEGER OldShowListPage,OldSeasonListPage,OldArtistListPage,OldAlbumListPage;
INTEGER TvShowID, TvShowSeasonID, TvShowEpisodeID, AlbumID, ArtistID;
INTEGER PlaylistIDs[100];						   // The songids/movieids etc. of the current playlist
STRING List_Plot$[10][1024];						   // An internal store of the Plot (which is a long string)
												   // done this way to circumvent limitation on length of
												   // indirect text to VT-Pro-e programs
INTEGER TCPBlocker;					// Semaphore for incomplete JSON packets. A packet is not complete
									// until we receive the '<EOF>' tag.
SIGNED_INTEGER PlaySpeed;			// Speed of current audio/video playback (1x, 2x, 4x etc.)
INTEGER IsTvShow;
INTEGER IsPlaying;

/*
  	Set the video outputs to appropiate state depending on current status
*/
Function SetVideoStatus(INTEGER Status)
{

	if (Status = ON)
	{
		ActivePlayer = ACTIVEPLAYER_VIDEO;
		PlayFb = ON;
		IsPlaying = 1;
		#IF_DEFINED DEBUG PRINT("ActivePlayer: %d (video)", ActivePlayer); #ENDIF
		IF (ISTvShow)
			Currently_Playing_Type = TYPE_SERIES;
		ELSE
			Currently_Playing_Type = TYPE_MOVIE;
	}
	else
	{
		ActivePlayer = ActivePlayer & 251; // switch off the 3rd bit
	}
}

/*
  	Set the audio outputs to appropiate state depending on current status
*/
Function SetAudioStatus(INTEGER Status)
{
	if (Status = ON)
	{
		PlayFb = ON;
		IsPlaying = 1;
		ActivePlayer = ACTIVEPLAYER_AUDIO;
		#IF_DEFINED DEBUG PRINT("ActivePlayer: %d (audio)", ActivePlayer); #ENDIF
		Currently_Playing_Type = TYPE_AUDIO; 
	}
	else
	{
		ActivePlayer = ActivePlayer & 254; // switch off the 1st bit
	}
}
  
/*
  	Set the picture outputs to appropiate state depending on current status
*/
Function SetSlideShowStatus(INTEGER Status)
{
	if (Status = ON)
	{
		ActivePlayer 	= 2;
		PlayFb 			= ON;
		IsPlaying 		= 1;
		#IF_DEFINED DEBUG PRINT("ActivePlayer: %d (slideshow)", ActivePlayer); #ENDIF
		Currently_Playing_Type = TYPE_PICTURES; //Pictures
	}
	else
	{
		ActivePlayer = ActivePlayer & 253; // switch off the 2nd bit
	}
}

/*******************************************************************************************
  XBMC Response logic
*******************************************************************************************/
/*
  	Return a string containing the xbmc parameter list for Video Playlists
*/
STRING_FUNCTION VideoPlaylistParameters(STRING AdditionalParameters, INTEGER start, INTEGER end
											,STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{%s\x22fields\x22:[%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22},\x22start\x22:%d,\x22end\x22:%d}"
								, AdditionalParameters
								,"\x22title\x22"
								,"\x22originaltitle\x22"
								,"\x22director\x22"
								,"\x22tagline\x22"
								,"\x22genre\x22"
								,"\x22showtitle\x22"
								,"\x22runtime\x22"
								,"\x22year\x22"
								,"\x22rating\x22"
								,"\x22writer\x22"
								,"\x22studio\x22"
								//,"\x22plotoutline\x22"
								,"\x22plot\x22"
								,"\x22season\x22"
								,"\x22episode\x22"
								,"\x22firstaired\x22"
								,"\x22studio\x22"
								,"\x22mpaa\x22"
								,"\x22playcount\x22"
								,SortMethod
								,start
								,end 
					);
 
	#IF_DEFINED DEBUG PRINT( "VideoPlaylistParameters:%s", LEFT(Params$,200)  ); #ENDIF

	RETURN (Params$);
}
/*
  	Return a string containing the xbmc parameter list for Audio Playlists
*/
STRING_FUNCTION AudioPlaylistParameters(STRING AdditionalParameters, INTEGER start, INTEGER end
											,STRING SortMethod) 
{
	STRING Params$[1024];

	// These labels from CFileItemHandler::FillVideoDetails in FileItemHandler.cpp (xbmc src code)
	MAKESTRING (Params$, 
	"{%s\x22fields\x22:[%s,%s,%s,%s,%s,%s,%s,%s],\x22sort\x22:{\x22method\x22:\x22%s\x22,\x22order\x22:\x22ascending\x22},\x22start\x22:%d,\x22end\x22:%d}"
								, AdditionalParameters
								,"\x22title\x22"
								,"\x22artist\x22"
								,"\x22album\x22"
								,"\x22genre\x22"
								,"\x22year\x22"
								,"\x22rating\x22"
								,"\x22duration\x22"
								,"\x22tracknumber\x22"
								,SortMethod
								,start
								,end 
					);
	#IF_DEFINED DEBUG PRINT( "AudioPlaylistParameters:%s", LEFT(Params$,200)  ); #ENDIF

	RETURN (Params$);
}

/*
    Take the uri given by XBMC and add http://, ip_address, port etc.
	When UseJPG = 1, Use the extension '.jpg' instead of '.tbn'.
*/
STRING_FUNCTION ThumbnailUri(STRING uri$, INTEGER UseJPG)
{
	STRING tmpCoverPath[512];
	IF(LOGIN <> "0d" && PASSWORD <> "0d"){
		tmpCoverPath = "http://" + LOGIN + ":" + PASSWORD + "@" + XBMC_IPAddr$ + ":"+ XBMC_Port$ + "/";
	}	
	ELSE{
		tmpCoverPath = "http://" + XBMC_IPAddr$ + ":"+ XBMC_Port$ + "/";
	}
	IF (UseJPG)
		tmpCoverPath = tmpCoverPath + "vfs:" + LEFT(uri$, LEN(uri$) - 4) + ".jpg";
	ELSE
		tmpCoverPath = tmpCoverPath + "vfs:" + uri$;
    RETURN (tmpCoverPath);
}


/*
	Set the outputs to a default empty state
*/
FUNCTION Initialize_Outputs()
{
	CurrentFilename$ = "";				// The file name of the currently playing track
	CurrentTitle$ = "";		    		// The name of the current track
	CurrentCoverArt$ = "";				// The uri of the coverart for the current track
	CurrentCoverArtJPEG$ = "";			// The uri of a JPEG of the coverart for the current track
    CurrentTime$ = "";					// The time that the movie/track ahs been playing
	CurrentDuration$ = "";				// total length of movie/track
	CurrentPercentage$ = "";			// the percent that the track has progressed
 	CurrentGenre$ = "";					// Music/Movie genre
	CurrentStudio$ = "";				// Movie studio
	CurrentDirector$ = "";				// The movie director's name.
    CurrentWriter$ = "";				// Movie writer
	CurrentTagLine$ = "";				// Movie tag line
	CurrentRating$ = "";				// imdb rating
	CurrentYear$ = "";					// The year the song/movie was released				
	CurrentShowTitle$ = "";				// TV Show title
	CurrentSeason$ = "";				// TV Show season
	CurrentEpisode$ = "";				// TV Show episode
	CurrentFirstAired$ = "";			// TV Show first aired date
	CurrentPlot$ = "";					// shortened version of plot
	CurrentTrackNumber$ = "";			// The track number				
	CurrentArtist$ = "";			    // The artist of the current track
	CurrentAlbum$ = "";			        // The album of the current track
	CurrentAudioBitRate$ = "";			// audio bitrate
	AudioCodec$ = "";					// audio codec
	VideoCodec$ = "";					// video codec
	NextTitle$ = "";					// Metadata about next item on playlist
	NextArtist$ = "";					//
	NextGenre$ = "";					//
	NextAlbum$ = "";					//
	NextTrackNumber$ = "";				//

	Progress_Percentage = 0;
	Position_Seconds = 0; 
	Duration_Seconds = 0;			
	Currently_Playing_Type = TYPE_NONE;

	PlaylistPosition = 0;
	ActivePlayer = ACTIVEPLAYER_NONE;
	ISTvShow = 0;

	PauseFb = OFF;
	StopFb = ON;
	PlayFb = OFF;

	CoverArtInternal$ = "";
}

/*
	Update IsVideo, IsAudio and IsSlideshow from GetActivePlayers response

	Expecting a response string of the form (ignoring whitespace): 
	 				{"audio":false,"picture":false,"video":false}

*/
FUNCTION GetActivePlayersFromResponse(STRING Response$)
{
	INTEGER Ind[1];			//Index variables used to parse the JSON response
    STRING  Value[5];		// temp variable to hold true/false value

    Ind[0] = FIND(":", Response$, FIND("audio", Response$)) + 1; 
	Ind[1] = FIND(",", Response$, Ind[0]) - 1;
	Value = MID(Response$, Ind[0], Ind[1]-Ind[0]+1);
	Value = TRIM(Value);

	IF (Value = "true")
	{
		SetAudioStatus(ON);
	}
	ELSE
	{
		SetAudioStatus(OFF);
    }                
    
	Ind[0] = 0; Ind[1] = 0;
	Ind[0] = FIND(":", Response$, FIND("picture", Response$)) + 1;
	Ind[1] = FIND(",", Response$, Ind[0]) - 1;
	IF (Ind[0] > 0 && Ind[1] > 0)
	{
		Value = MID(Response$, Ind[0], Ind[1]-Ind[0]+1);
		Value = TRIM(Value);

		IF (Value = "true")
			SetSlideShowStatus(ON);
		ELSE
			SetSlideShowStatus(OFF);
       }

	Ind[0] = 0; Ind[1] = 0;
	Ind[0] = FIND("video", Response$);
	Ind[0] = FIND(":", Response$, Ind[0]) + 1;
	Ind[1] = FIND("}", Response$, Ind[0]) - 1; // assumes video always comes last
	IF (Ind[0] > 0 && Ind[1] > 0)
	{
		Value = MID(Response$, Ind[0], Ind[1]-Ind[0]+1);
		Value = TRIM(Value);

		IF (Value = "true") 
			SetVideoStatus(ON);
		ELSE
			SetVideoStatus(OFF);
	}
	
	IF (!ActivePlayer) 
	{
		PauseFb = OFF;
		StopFb = ON;
		PlayFb = OFF;
		IsPlaying = 0;
		Currently_Playing_Type 	= TYPE_NONE;
	}
}


/*
    Update metadata of currently playing (and next playing) using response that returned a playlist

	Item$:			The JSON description of the Item
	NextInPlaylist:	When =1 then Item$ contains details of the next track in the playlist
					When =0 then Item$ contains details of the current track in the playlist		
*/
FUNCTION GetMetadataFromList(STRING Item$, INTEGER NextInPlaylist)
{
	INTEGER Ind[2];					//Index variables used to parse the reponse
	STRING Info[40][255];			//An array of currently playing information
	STRING Category[40][40];		//An array of the type of Info e.g. Genre, Artist etc.	  
	INTEGER i,j;					//Loop vars
	STRING CoverartTmp[512];//The coverart uri. Must be treated as a special case due to TPS-6X limitations

	i=0; j=0; Ind[0] = Find("{", Item$)+1;

	#IF_DEFINED DEBUG PRINT("Item$: %s", LEFT(Item$, 245)); #ENDIF

	// Parse the JSON items list into an array of Info & Categories
	While(Ind[0])
	{
		Ind[1] = Find(":", Item$, Ind[0]);
		If(Ind[1] )
		{

			Ind[2] = Find(",\x0A", Item$, Ind[1]); // Each list item is separated by a comma, followed by a line-feed
			IF ( Ind[2] = 0) Ind[2] = ReverseFind("}", Item$)-1; // must be the end of the list

			Category[j] = RemoveDoubleQuotesAndWhitespace( Mid(Item$, Ind[0]+1, Ind[1]-Ind[0]-1) );
			
            Info[j] = LEFT(RemoveDoubleQuotesAndWhitespace( Mid(Item$, Ind[1]+1, Ind[2]-Ind[1]-1) ),255);

			#IF_DEFINED DEBUG 
				PRINT( "%s: %s\n", Category[j], LEFT(Info[j],220)  ); 
			#ENDIF

			j=j+1;
			
			Ind[0] = Ind[2];

			// Emergency bailout
			IF (J > 39) Ind[0] = 0;

		}
		Else Ind[0] = 0;
	} 
    
	// Assign to OUTPUTs
	IF(!NextInPlaylist)
	{
		FOR (i = 0 to j-1)
		{
	     	IF (Category[i] = "file") CurrentFilename$ = RIGHT(Info[i],255); //SIMPL strings can only be 255 chars long
			ELSE IF(Category[i] = "title") CurrentTitle$ = Info[i];
			ELSE IF(Category[i] = "tracknumber") CurrentTrackNumber$ = Info[i];
			ELSE IF(Category[i] = "artist") CurrentArtist$ = Info[i];
	 		ELSE IF(Category[i] = "album") CurrentAlbum$ = Info[i];
			ELSE IF(Category[i] = "genre") CurrentGenre$ = Info[i];
			ELSE IF(Category[i] = "director") CurrentDirector$ = Info[i];
			ELSE IF(Category[i] = "year") CurrentYear$ = Info[i];
			ELSE IF(Category[i] = "musicplayer.bitrate") CurrentAudioBitRate$ = Info[i];
			ELSE IF(Category[i] = "musicplayer.codec") AudioCodec$ = Info[i];
			ELSE IF(Category[i] = "videoplayer.videocodec") VideoCodec$ = Info[i];
			ELSE IF(Category[i] = "rating") CurrentRating$ = Round(Info[i],2);		
	        ELSE IF(Category[i] = "studio") CurrentStudio$ = Info[i];
			ELSE IF(Category[i] = "writer") CurrentWriter$ = Info[i];
			ELSE IF(Category[i] = "showtitle") CurrentShowTitle$ = Info[i];
			ELSE IF(Category[i] = "season") CurrentSeason$ = Info[i];
			ELSE IF(Category[i] = "episode") CurrentEpisode$ = Info[i];
			ELSE IF(Category[i] = "firstaired") CurrentFirstAired$ = Info[i];
			ELSE IF(Category[i] = "tagline") CurrentTagLine$ = Info[i];
			ELSE IF(Category[i] = "plot") CurrentPlot$ = LEFT(Info[i],200); //width restriction imposed			ELSE IF(Category[i] = "plotoutline") CurrentPlotOutline$ = Info[i];
			ELSE IF(Category[i] = "thumbnail") 
			{
				CurrentCoverArt$ = ThumbnailUri(Info[i],UseJpgExtension);
				CoverartTmp = ThumbnailUri(Info[i],UseJpgExtension);
			}
			ELSE IF(Category[i] = "time") 
			{
				Position_Seconds = AtoI(Info[i]);
				CurrentTime$ = ConvertToTime(Position_Seconds);
			}
			ELSE IF(Category[i] = "total") 
			{
				Duration_Seconds = AtoI(Info[i]);
				CurrentDuration$ = ConvertToTime(Duration_Seconds);					
			}
			ELSE IF(Category[i] = "Playlist.position")
			{
				PlaylistPosition = AtoI(Info[i]);
	            IF (PlaylistPosition)
					PlaylistPosition = PlaylistPosition -1; // make it zero-based    	
				ELSE
					CALL Initialize_Outputs();
	            #IF_DEFINED DEBUG PRINT("PlaylistPosition: %d", PlaylistPosition); #ENDIF
			}
		}
	    
		// Only update the String_output if the coverart has actually changed
		// This is b'cos the TPS-6X is easily overloaded by dynamic graphic calls
		IF (LEN(CoverartTmp) && CoverartTmp <> CoverArtInternal$) 
		{
			#IF_DEFINED DEBUG PRINT("Coverart Updated."); #ENDIF
			CoverArtInternal$ = CoverartTmp;
			CurrentCoverArtJPEG$ = CoverartTmp;
		}    
	}
	ELSE
	{
		FOR (i = 0 to j-1)
		{
	     	IF(Category[i] = "title") NextTitle$ = Info[i];
			ELSE IF(Category[i] = "tracknumber") NextTrackNumber$ = Info[i];
			ELSE IF(Category[i] = "artist") NextArtist$ = Info[i];
	 		ELSE IF(Category[i] = "album") NextAlbum$ = Info[i];
			ELSE IF(Category[i] = "genre") NextGenre$ = Info[i];
		}
	}
}

/*
    Update metadata using response from a JSON call that returned a list
*/
FUNCTION GetMetadataFromResponse(STRING Response$)
{
	INTEGER ItemsArrayBookends[2];	//Start and end of the items list
	INTEGER ListItemBookends[2];	//Start and end of an item in the items list
	STRING Item$[16384];			//A single item

	// Assumption:
	// The first item in the array contains details of the track that's currently playing
	// The second item in the array contains details of the track that's next in the playlist

	// Mark out the start and end of (i) the "items" array and (ii) the first item in the array
	ItemsArrayBookends[0] = Find("[", Response$);    
	ItemsArrayBookends[1] = Find("]", Response$, ItemsArrayBookends[0]);
	ListItemBookends[0] = Find("{", Response$, ItemsArrayBookends[0]);    
	ListItemBookends[1] = Find("}", Response$, ListItemBookends[0]); 

	Item$ = MID(Response$, ListItemBookends[0], ListItemBookends[1] - ListItemBookends[0]);  
 
	CALL GetMetadataFromList(Item$, 0);

	// Mark out the start and end of the second item in the array
	ListItemBookends[0] = Find("{", Response$, ListItemBookends[1]);    
	ListItemBookends[1] = Find("}", Response$, ListItemBookends[0]);
	IF ( ListItemBookends[1] = 0) ListItemBookends[1] = LEN(Response$);
    #IF_DEFINED DEBUG PRINT("ListItemBookends[0]: %d, ListItemBookends[1]: %d", 
					ListItemBookends[0],ListItemBookends[1]); #ENDIF
	Item$ = MID(Response$, ListItemBookends[0], ListItemBookends[1] - ListItemBookends[0]); 

	CALL GetMetadataFromList(Item$, 1);

}

/*
    Update the duration and time of the current track
*/
FUNCTION GetTimeFromResponse(STRING Response$)
{
	INTEGER ListItemBookends[2];	//Start and end of an item in the items list
	STRING Item$[1000];				//A single item

	// Mark out the start and end of (i) the "items" array and (ii) the first item in the array
	// The first item in the array contains details of the track that's currently playing
	ListItemBookends[0] = Find("{", Response$);    
	ListItemBookends[1] = Find("}", Response$, ListItemBookends[0]); 

	Item$ = MID(Response$, ListItemBookends[0], ListItemBookends[1] - ListItemBookends[0]);  
 
	CALL GetMetadataFromList(Item$, 0);
}

/*
    Return a JSON array with the given name.

	ArrayName: e.g. "\x22movies\x22", "\x22episodes\x22" etc.
*/
STRING_FUNCTION GetArrayFromResponse(STRING ArrayName, STRING Response$)
{
    STRING Array$[16384];

	INTEGER FirstSquareBracket; 
	INTEGER LastSquareBracket; 
    
    #IF_DEFINED DEBUG PRINT("Response$: %s", LEFT(Response$, 200)); #ENDIF

	FirstSquareBracket = FIND("[\x0A", Response$, Find(ArrayName, Response$)) + 3;
	LastSquareBracket = ReverseFind("],\x0A", Response$); 
	IF (LastSquareBracket = 0)
		LastSquareBracket = ReverseFind("]", Response$); 
	//#IF_DEFINED DEBUG PRINT("FirstSquareBracket: %d, LastSquareBracket: %d", FirstSquareBracket, LastSquareBracket); #ENDIF
	Array$ = MID(Response$, FirstSquareBracket, LastSquareBracket - FirstSquareBracket);
    //#IF_DEFINED DEBUG PRINT("MovieList$: %s", LEFT(MovieList$, 200)); #ENDIF

	RETURN (Array$);
}
   
/*
    Get the value of the "total" field in a List Response
*/
INTEGER_FUNCTION GetListTotalFromResponse(STRING Result$)
{
    STRING Total$[10];
    
	INTEGER IndexOfTotal;
	INTEGER IndexOfColon; 
	INTEGER IndexOfNextComma;
	INTEGER IndexOfOpeningArrayBracket;

	IndexOfTotal = Find("\x22total\x22", Result$); 
    
	IndexOfColon = FIND(":", Result$, IndexOfTotal);
	IndexOfNextComma = Find(",", Result$, IndexOfColon);
	IF (IndexOfNextComma=0)
		IndexOfNextComma = Find("}", Result$, IndexOfColon);

	Total$ = MID(Result$, IndexOfColon+1, IndexOfNextComma - IndexOfColon-1);
    #IF_DEFINED DEBUG PRINT("Total$: %s", Total$); #ENDIF

	RETURN (AtoI(Total$));
}

/*

*/
FUNCTION ParseAnnouncementMessage(STRING Announcement$)
{
	INTEGER Ind[2];			//Index variables used to parse the response 
    STRING Message$[100];
	STRING TempSpeed$[3];
	
	Ind[0] = FIND("message", Announcement$);
	Ind[1] = FIND(":", Announcement$, Ind[0]) + 1;
	Ind[2] = FIND(",", Announcement$, Ind[1]);

	Message$ = MID(Announcement$, Ind[1], Ind[2] - Ind[1]);

	PRINT("Message: %s\n", Message$);

	If(Find("Action", Message$) || Find("PlayBackSeek",Message$) 
						|| Find("MediaChanged",Message$)
						|| Find("QueueNextItem", Message$) )
	{
		// Do Nothing
	}
	Else If(Find("SpeedChanged", Message$))
	{                
		Ind[0] = FIND("speed", Announcement$);
		Ind[1] = FIND(":", Announcement$, Ind[0]) + 1;
		Ind[2] = FIND("}", Announcement$, Ind[1]) - 1;
		TempSpeed$ = TRIM(mid(Announcement$, Ind[1], Ind[2] - Ind[1])); 

		if (Find("-",TempSpeed$)) 
			PlaySpeed 	= -(atoi(TempSpeed$));
		else
			PlaySpeed 	= atoi(TempSpeed$);
		
		MakeString(PlayingSpeed$,"%dx",PlaySpeed); 
	}	
	Else If(Find("PlaybackStarted", Message$))
	{
		PauseFb		= 0; 
		StopFb		= 0; 
		PlayFb		= 1; 
		PlaySpeed	= 1; 
		Makestring(PlayingSpeed$, "%dx", PlaySpeed);
		PlayStatus$ = "Playing";
		//CALL UpdateMetadata();
	}
	Else If(Find("PlaybackPaused", Message$)) 
	{
		StopFb			= 0; 
		PlayFb			= 0; 
		PauseFb			= 1; 
		PlayingSpeed$ 	= ""; 
		PlayStatus$ = "Paused";
	}
	Else If(Find("PlaybackEnded", Message$) || Find("PlaybackStopped", Message$))
	{
		PlayFb					= 0; 
		PauseFb					= 0;
		StopFb					= 1; 
		PlayingSpeed$ 			= ""; 
		PlayStatus$ = "Stopped";
		CALL Initialize_Outputs();
	}
	Else If(Find("PlaybackResumed", Message$))
	{
		PauseFb					= 0; 
		StopFb					= 0; 
		PlayFb					= 1; 
		PlaySpeed				= 1; 
		PlayStatus$ = "Playing";
		Makestring(PlayingSpeed$, "%dx", PlaySpeed);
		Wait(100) 
		{ 
			//CALL UpdateMetadata();
			//CALL Initialize_Outputs(); 
		}
	}
	Else If(Find("StartUp", Message$) > 0)
	{
		CALL Initialize_Outputs();
	}
	Else
		PRINT("XBMC.usp: Unknown announcement: %s\n", LEFT(Message$,200));
}

/*
  	Take the raw JSON result string and send it to the correct parsing function
*/
FUNCTION ParseJSONResult(INTEGER id, STRING Result$)
{
	IF (id = REQUESTID_GETACTIVEPLAYERS)
	{
		CALL GetActivePlayersFromResponse(Result$);
	}
	ELSE IF (id = REQUESTID_GETINFOLABELS)
	{
		CALL GetMetadataFromList(Result$, 0);
	}
	ELSE IF (id = REQUESTID_AUDIOPLAYLIST_GETITEMS)
	{
		CALL GetMetadataFromResponse(Result$);	
	}
	ELSE IF (id = REQUESTID_VIDEOPLAYLIST_GETITEMS)
	{
		IF ( FIND("showtitle",Result$) )
			IsTVShow = 1; 
		ELSE 
			IsTVShow = 0;
		CALL GetMetadataFromResponse(Result$);
	}
	ELSE IF (id = REQUESTID_GETTIME_SECONDS)
	{
		CALL GetTimeFromResponse(Result$);
	}
	ELSE IF (id = REQUESTID_GETTIME_PERCENTAGE)
	{
		// XBMC does not return JSON in this case
		CurrentPercentage$ = Round(Result$,0)+"%";
		Progress_Percentage = AtoI(Round(Result$,0));
	}
	ELSE IF (ID = REQUESTID_MOVIELIBRARY_GETMOVIES
				|| ID = REQUESTID_MOVIELIBRARY_GETTVSHOWS
				|| ID = REQUESTID_MOVIELIBRARY_GETTVSEASONS
				|| ID = REQUESTID_MOVIELIBRARY_GETTVEPISODES
				|| ID = REQUESTID_AUDIOLIBRARY_GETARTISTS
				|| ID = REQUESTID_AUDIOLIBRARY_GETALBUMS
				|| ID = REQUESTID_AUDIOLIBRARY_GETSONGS
				|| ID = REQUESTID_PLAYLIST_PLAYALLLIST)
    {
        // Do Nothing.
		// Handled by XBMC-Browse		
	}
	ELSE IF (FIND("OK", Result$) || (FIND("success", Result$) && FIND("true", Result$)))
	{
		// Got an 'OK' result
    	// Do nothing
	}
	ELSE
	{
		GenerateUserError("%s: Unhandled Result string. id=%d, Result=%s", 
				GetSymbolInstanceName(), id, LEFT(Result$,100));
	}

}

/*
  	Take the raw JSON error string and print it to Trace. 
	In future maybe I'll send it to the correct parsing function.
*/
FUNCTION ParseJSONError(INTEGER id, STRING Result$)
{
	Print("XBMC.usp: id:%d error:'%s'", id, LEFT(Result$,100));
}
      
/*
	Determine request id
*/
INTEGER_FUNCTION GetRequestID(STRING IN$)
{
    INTEGER Ind[1];		// Indices used in parsing input string
	STRING ID$[10];
	
	Ind[0] = FIND("id", IN$);
	Ind[0] = FIND(":", IN$, Ind[0]) + 1;
	Ind[1] = FIND(",\x0A", IN$, Ind[0]) - 1; 
	ID$ = MID(IN$, Ind[0], Ind[1] - Ind[0] + 1);
    ID$ = TRIM(ID$);

	RETURN (AtoI(ID$));
}
/*******************************************************************************************
  TCPIP Connection
*******************************************************************************************/ 

CHANGE Rx$
{
	INTEGER ID;  				// The request id. It is used to match the response
								// with the request that it is replying to.
	    
	STRING Response$[65534]; 	// The response from XBMC
	INTEGER Ind[2];				//Index variables used to parse the response  
                     
	//Semaphore
	WHILE (TCPBlocker) 
	{	
		Delay(10);
	}	
	TCPBlocker = 1;
    
	// Test for empty buffer (Can happen if buffer emptied by earlier event)
	IF (LEN(Rx$) = 0) 
	{
		TCPBlocker = 0;
		TERMINATEEVENT;
	}

	DO
	{
		Response$ = GATHER("<EOF>", Rx$, GATHER_TIMEOUT);		
	} 
	UNTIL (LEN(Response$));
    
	Response$ = LEFT(Response$, LEN(Response$) - 5); // remove <EOF> delimiter

	// Process the JSON payload, which is now in the Response$ variable
	IF (FIND ("result", Response$))
	{

		// Determine request id
        ID = GetRequestID(Response$);
              
		// 'result' string within XBMC Response
		Ind[0] = FIND ("{", Response$, Ind[0]);
		IF (Ind[0])
			Ind[1] = REVERSEFIND ("}\x0A", Response$);
		ELSE
		{
            Ind[0] = FIND (":", Response$, FIND ("result", Response$)) + 1;
			Ind[1] = REVERSEFIND ("\x0A}", Response$);
		}

		Response$ = MID(Response$, Ind[0], Ind[1] - Ind[0]);

		IF (ID)
			CALL ParseJSONResult(ID, Response$);  	
	}
	// Announcement?
	ELSE IF (FIND ("Announcement", Response$))
	{
       	Ind[0] = FIND (":", Response$, FIND ("params", Response$)) + 1;
		Ind[1] = REVERSEFIND ("\x0A}", Response$);
		
		Response$ = MID(Response$, Ind[0], Ind[1] - Ind[0]);

        CALL ParseAnnouncementMessage(Response$);
	}
	// JSON error?
	ELSE IF (FIND ("error", Response$))
	{
		// Determine request id
           ID = GetRequestID(Response$);
              
		// 'error' string within XBMC Response
           Ind[0] = FIND (":", Response$, FIND ("error", Response$)) + 1;
		Ind[1] = REVERSEFIND ("\x0A}", Response$);

		Response$ = MID(Response$, Ind[0], Ind[1] - Ind[0]);
                 
		IF (ID)
			CALL ParseJSONError(ID, Response$);
		ELSE 
			Print("XBMC.usp: id:%d error:%s", ID, LEFT(Response$,200));
	}
	ELSE
	{
		Print("Unrecognised Payload: %s", LEFT(Response$,200));
	}	

                
	// Reset the flag to zero
	TCPBlocker = 0;


}

/*******************************************************************************************
  Functions
  Note:  Functions must be physically placed before the location in
         the code that calls them.
*******************************************************************************************/

/*
	Send the JSON-RPC Post command
*/
Function SendJsonCommand(INTEGER id,  STRING Command , STRING Arguments)
{
	STRING Command$[16384];

    IF (LEN(Arguments) = 0)
	{
		// \x22 is a double quote (")
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22}"
			,id ,Command);
	}
	ELSE
	{
		MAKESTRING (Command$, 
			"{\x22id\x22:%d,\x22jsonrpc\x22:\x222.0\x22,\x22method\x22:\x22%s\x22,\x22params\x22:%s}"
			,id ,Command, Arguments);
	}	

	// Send out the command in chunks
	WHILE (LEN(Command$))
	{
		IF (LEN(Command$)>200)
		{
			// Send to serial out
			Tx$ = REMOVEBYLENGTH(200, Command$);
		}
		ELSE
		{
			// Append a delimiter ('\n') and send to serial out
			MAKESTRING(Tx$, "%s\n", Command$);
			Command$ = "";
		}
	}
	                        
}


/* 
	Retrieve Current Player
*/
FUNCTION GetActivePlayers()
{
	CALL SendJsonCommand (REQUESTID_GETACTIVEPLAYERS, "Player.GetActivePlayers", "");
}
/*
	Retrieve current playlist position
*/
FUNCTION GetCurrentPlaylistPositionAndInfoLabels()
{
	STRING Params$[1024];

	MAKESTRING(Params$, "[%s,%s,%s,%s]"
								,"\x22Playlist.position\x22" // \x22 is a double quote (")
								,"\x22musicplayer.bitrate\x22"
								,"\x22musicplayer.codec\x22"
								,"\x22videoplayer.videocodec\x22"
			);
						  					      
 	CALL SendJsonCommand (REQUESTID_GETINFOLABELS, "System.GetInfoLabels", Params$);

	// Note:
	// Usable info labels defined in http://wiki.xbmc.org/?title=InfoLabels
	// and implemented in TranslateSingleString in GUIInfoManager.cpp (xbmc src code)
}

/*
	Retrieve current time & percentage progress through track
*/
FUNCTION GetCurrentTime()
{
	// If playing on an external player then don't use this function
	IF(IsPlayingOnExternalPlayer) RETURN;	

	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) //audio
	{
		CALL SendJsonCommand (REQUESTID_GETTIME_SECONDS, 
										"AudioPlayer.GetTime", "");
		DELAY(JSON_DELAY);
		CALL SendJsonCommand (REQUESTID_GETTIME_PERCENTAGE, 
									"AudioPlayer.GetPercentage","");
	}
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
	{
		CALL SendJsonCommand (REQUESTID_GETTIME_SECONDS, 
											"VideoPlayer.GetTime", "");
		DELAY(JSON_DELAY);
		CALL SendJsonCommand (REQUESTID_GETTIME_PERCENTAGE, 
									"VideoPlayer.GetPercentage", "");
	}
	ELSE
	{
		CurrentTime$ = "";
		CurrentDuration$ = "";
		Progress_Percentage = 0;
		Position_Seconds = 0;
		Duration_Seconds = 0;
	}
}


/*
	Retrieve current time & percentage progress through track
*/
FUNCTION UpdateMetadata()
{
	CALL GetActivePlayers();	
    
	DELAY(JSON_DELAY);
	CALL GetCurrentPlaylistPositionAndInfoLabels();

	DELAY(JSON_DELAY);
	//ProcessLogic();
  	
	// only return the current item and one more
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO)
	{
    	CALL SendJsonCommand (REQUESTID_AUDIOPLAYLIST_GETITEMS, 
									"AudioPlaylist.GetItems", 
									AudioPlaylistParameters("", 
								PlaylistPosition, PlaylistPosition+1, "track"));
	}
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO)
	{
		CALL SendJsonCommand (REQUESTID_VIDEOPLAYLIST_GETITEMS, 
			"VideoPlaylist.GetItems", VideoPlaylistParameters("",
								PlaylistPosition,PlaylistPosition+1,"sorttitle"));		
	}

}

 
/********************************************************************************
*
* EVENT handlers
*
********************************************************************************/

push PlayNext
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO)
		CALL SendJsonCommand (REQUESTID_SKIPNEXT, "AudioPlaylist.SkipNext","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO)
		CALL SendJsonCommand (REQUESTID_SKIPNEXT, "VideoPlaylist.SkipNext", "");
}
push PlayPrev
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_SKIPPREV, "AudioPlaylist.SkipPrev","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_SKIPPREV, "VideoPlaylist.SkipPrev", "");
} 
push JumpFwd_Sm
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPFORWARD, 
									"AudioPlayer.SmallSkipForward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPFORWARD, 
									"VideoPlayer.SmallSkipForward", "");
}
push JumpFwd_Lg
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPFORWARD, 
									"AudioPlayer.BigSkipForward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPFORWARD, 
									"VideoPlayer.BigSkipForward", "");
}
push JumpBack_Sm
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPBACKWARD, 
									"AudioPlayer.SmallSkipBackward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_SMALLSKIPBACKWARD, 
									"VideoPlayer.SmallSkipBackward", "");
}
push JumpBack_Lg
{
	IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPBACKWARD, 
									"AudioPlayer.BigSkipBackward","");
	ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
		CALL SendJsonCommand (REQUESTID_LARGESKIPBACKWARD, 
									"VideoPlayer.BigSkipBackward", "");
}    
push CheckCurrentlyPlaying
{
	CALL UpdateMetadata();
}
PUSH ClearCurrentlyPlaying
{
 	CALL Initialize_Outputs();
}
PUSH Get_Time
{
	IF (IsPlaying)
		CALL GetCurrentTime();
} 
push UpdateMovies
{
	CALL SendJsonCommand (REQUESTID_VIDEOLIBRARY_SCAN, 
								"VideoLibrary.ScanForContent", "");
}  
push UpdateMusic
{
    CALL SendJsonCommand (REQUESTID_AUDIOLIBRARY_SCAN, 
								"AudioLibrary.ScanForContent", "");

} 


CHANGE Seek_Percentage
{
	STRING Time$[10];
	MAKESTRING(Time$, "%d", Seek_Percentage);
    
	IF (IsPlaying)
	{
		IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
			CALL SendJsonCommand (30, "AudioPlayer.SeekPercentage",Time$);
		ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
			CALL SendJsonCommand (30, "VideoPlayer.SeekPercentage", Time$);
	}

}

CHANGE Seek_Time
{
	STRING Time$[10];
	MAKESTRING(Time$, "%d", Seek_Time);
    
	IF (IsPlaying)
	{
		IF (ActivePlayer = ACTIVEPLAYER_AUDIO) 
			CALL SendJsonCommand (31, "AudioPlayer.SeekTime",Time$);
		ELSE IF (ActivePlayer = ACTIVEPLAYER_VIDEO) 
			CALL SendJsonCommand (31, "VideoPlayer.SeekTime", Time$);
	}
}

  
///////////// Initialization script
Function Main()
{                            
	// This line must be before WaitForInitializationComplete()
	// This IP address is passed to XBMC-ES via this output
	IPAddress$ = XBMC_IPAddr$;

	List_PageNumber = 0;

	WaitForInitializationComplete();
     

}
       